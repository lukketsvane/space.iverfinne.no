=== /workspaces/space.iverfinne.no/components/gallery-page.tsx ===

"use client"

import { BulkActionBar } from "@/components/gallery/bulk-action-bar"
import { SettingsPanel } from "@/components/gallery/settings-panel"
import { FolderDescriptionDialog, ItemContextMenu, NewFolderDialog, RenameDialog } from "@/components/gallery/ui-components"
import { CaptureController, ModelViewer, SpotLightInScene } from "@/components/gallery/viewer-components"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger
} from "@/components/ui/dropdown-menu"
import { Input } from "@/components/ui/input"
import { Skeleton } from "@/components/ui/skeleton"
import { Switch } from "@/components/ui/switch"
import { useIsMobile } from "@/hooks/use-mobile"
import { lightingPresets } from "@/lib/lighting-presets"
import { cn } from "@/lib/utils"
import type { Folder, GalleryItem, Light, Model, ViewSettings } from "@/types"
import { Bounds, GizmoHelper, GizmoViewport, OrbitControls, OrthographicCamera, PerspectiveCamera, useGLTF } from "@react-three/drei"
import { Canvas } from "@react-three/fiber"
import { Bloom, EffectComposer } from "@react-three/postprocessing"
import { upload } from "@vercel/blob/client"
import { ChevronDown, ChevronLeft, Dice5, Download, Globe, Info, ListFilter, Lock, Palette, Plus, Search, Upload } from "lucide-react"
import { useRouter, useSearchParams } from "next/navigation"
import type React from "react"
import { Fragment, Suspense, useCallback, useEffect, useMemo, useRef, useState } from "react"
import useSWR, { useSWRConfig } from "swr"
import * as THREE from "three"
import type { OrbitControls as OrbitControlsImpl } from "three-stdlib"

useGLTF.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/")
const fetcher = (url: string) => fetch(url).then((res) => res.json())

type Pill = "all" | "models" | "public" | "drafts"

export default function GalleryPage() {
  const { mutate } = useSWRConfig()
  const router = useRouter()
  const searchParams = useSearchParams()
  const modelId = searchParams.get("modelId")
  const currentFolderId = searchParams.get("folderId") || null
  const isMobile = useIsMobile()

  const [breadcrumbs, setBreadcrumbs] = useState([{ id: null as string | null, name: "Assets" }])
  const [searchQuery, setSearchQuery] = useState("")
  const [sortOption, setSortOption] = useState("created_at-desc")
  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set())
  const [pill, setPill] = useState<Pill>("all")
  const lastSelectedItem = useRef<string | null>(null)

  const [filterVisibility, setFilterVisibility] = useState<"all" | "public" | "private">("all")
  const [filterFolderIds, setFilterFolderIds] = useState<Set<string>>(new Set())
  const [filterDate, setFilterDate] = useState<"any" | "24h" | "7d" | "30d" | "365d">("any")
  const [filterHasThumb, setFilterHasThumb] = useState<"any" | "yes" | "no">("any")

  const [sortBy, sortOrder] = sortOption.split("-")
  const galleryUrl = `/api/gallery?folderId=${currentFolderId || ""}&sortBy=${sortBy}&sortOrder=${sortOrder}`
  const { data: gallery, error, isLoading } = useSWR<{ folders: Folder[]; models: Model[]; currentFolder: Folder | null }>(galleryUrl, fetcher)

  const { data: allFolders } = useSWR<Folder[]>("/api/folders/all", fetcher)
  const { data: selectedModel, mutate: mutateSelectedModel } = useSWR<Model>(modelId ? `/api/models/${modelId}` : null, fetcher)
  const { data: breadcrumbData } = useSWR<{ id: string; name: string }[]>(currentFolderId ? `/api/folders/${currentFolderId}/breadcrumbs` : null, fetcher)

  useEffect(() => {
    if (document.querySelector('meta[name="apple-mobile-web-app-capable"]')) return

    const metaTags = [
      { name: "apple-mobile-web-app-capable", content: "yes" },
      { name: "apple-mobile-web-app-status-bar-style", content: "black-translucent" }
    ]

    metaTags.forEach((tagInfo) => {
      const meta = document.createElement("meta")
      meta.name = tagInfo.name
      meta.content = tagInfo.content
      document.head.appendChild(meta)
    })
  }, [])

  useEffect(() => {
    setBreadcrumbs(currentFolderId === null ? [{ id: null, name: "Assets" }] : [{ id: null, name: "Assets" }, ...(breadcrumbData || [])])
  }, [currentFolderId, breadcrumbData])

  const [refreshKey, setRefreshKey] = useState(0)
  const [allModelsCombined, setAllModelsCombined] = useState<Model[] | null>(null)

  useEffect(() => {
    let cancelled = false
    const load = async () => {
      const ids = [null, ...((allFolders ?? []).map((f) => f.id))]
      const results = await Promise.all(
        ids.map((fid) =>
          fetch(`/api/gallery?folderId=${fid ?? ""}&sortBy=created_at&sortOrder=desc`)
            .then((r) => (r.ok ? r.json() : null))
            .catch(() => null)
        )
      )
      const models: Model[] = results.flatMap((r) => (r && Array.isArray(r.models) ? (r.models as Model[]) : []))
      const uniq = new Map<string, Model>()
      models.forEach((m) => uniq.set(m.id, m))
      if (!cancelled) setAllModelsCombined(Array.from(uniq.values()))
    }
    load()
    return () => {
      cancelled = true
    }
  }, [allFolders, refreshKey])

  const gridModels: (Model & { type: "model" })[] = useMemo(() => {
    const list = (allModelsCombined ?? gallery?.models ?? []) as Model[]
    return list.map((m) => ({ ...m, type: "model" as const }))
  }, [allModelsCombined, gallery?.models])

  const folderById = useMemo(() => {
    const map = new Map<string, Folder>()
      ; (allFolders ?? []).forEach((f) => map.set(f.id, f))
    return map
  }, [allFolders])

  const filteredItems = useMemo(() => {
    const q = searchQuery.trim().toLowerCase()
    const cutoff = (() => {
      const now = Date.now()
      if (filterDate === "24h") return now - 24 * 3600 * 1000
      if (filterDate === "7d") return now - 7 * 24 * 3600 * 1000
      if (filterDate === "30d") return now - 30 * 24 * 3600 * 1000
      if (filterDate === "365d") return now - 365 * 24 * 3600 * 1000
      return null
    })()
    const matchesFolderChain = (folderId: string | null | undefined) => {
      if (!q) return false
      let cur = folderId ? folderById.get(folderId) : null
      while (cur) {
        if ((cur.name || "").toLowerCase().includes(q) || (cur.description || "").toLowerCase().includes(q)) return true
        cur = cur.parent_id ? folderById.get(cur.parent_id as any) : null
      }
      return false
    }
    const base = gridModels.filter((m) => {
      if (pill === "public" && !m.is_public) return false
      if (pill === "drafts" && m.is_public) return false
      if (filterVisibility === "public" && !m.is_public) return false
      if (filterVisibility === "private" && m.is_public) return false
      if (filterFolderIds.size > 0 && !filterFolderIds.has(m.folder_id || "")) return false
      if (filterHasThumb === "yes" && (!m.thumbnail_url || m.thumbnail_url.includes("/placeholder.svg"))) return false
      if (filterHasThumb === "no" && m.thumbnail_url && !m.thumbnail_url.includes("/placeholder.svg")) return false
      if (cutoff) {
        const ts = new Date((m as any).updated_at || m.created_at).getTime()
        if (Number.isFinite(ts) && ts < cutoff) return false
      }
      if (!q) return true
      const nameHit = m.name.toLowerCase().includes(q)
      const folderHit = matchesFolderChain(m.folder_id)
      return nameHit || folderHit
    })
    const sorted = [...base].sort((a, b) => {
      if (sortBy === "name") {
        const r = a.name.localeCompare(b.name)
        return sortOrder === "asc" ? r : -r
      }
      if (sortBy === "updated_at") {
        const ra = new Date((a as any).updated_at || a.created_at).getTime()
        const rb = new Date((b as any).updated_at || b.created_at).getTime()
        return sortOrder === "asc" ? ra - rb : rb - ra
      }
      if (sortBy === "visibility") {
        const va = a.is_public ? 1 : 0
        const vb = b.is_public ? 1 : 0
        return sortOrder === "asc" ? va - vb : vb - va
      }
      if (sortBy === "created_at") {
        const ra = new Date(a.created_at as any).getTime()
        const rb = new Date(b.created_at as any).getTime()
        return sortOrder === "asc" ? ra - rb : rb - ra
      }
      return 0
    })
    return sorted
  }, [gridModels, pill, searchQuery, folderById, filterFolderIds, filterVisibility, filterHasThumb, filterDate, sortBy, sortOrder])

  const [materialMode, setMaterialMode] = useState<"pbr" | "normal" | "white">("white")
  const [isSettingsPanelOpen, setIsSettingsPanelOpen] = useState(!isMobile)
  const [lightsEnabled, setLightsEnabled] = useState(true)
  const [environmentEnabled, setEnvironmentEnabled] = useState(false)
  const [bloomEnabled, setBloomEnabled] = useState(false)
  const [bgType, setBgType] = useState<"color" | "gradient" | "image">("color")
  const [bgColor1, setBgColor1] = useState("#000000")
  const [bgColor2, setBgColor2] = useState("#1a1a1a")
  const [bgImage, setBgImage] = useState<string | null>(null)
  const [lights, setLights] = useState<Light[]>([])
  const [selectedLightId, setSelectedLightId] = useState<number | null>(null)

  const [fov, setFov] = useState(50)
  const [isOrthographic, setIsOrthographic] = useState(false)
  const [cameraPosition, setCameraPosition] = useState<[number, number, number]>([5, 5, 5])
  const [cameraTarget, setCameraTarget] = useState<[number, number, number]>([0, 0, 0])

  const [matOverrideEnabled, setMatOverrideEnabled] = useState(false)
  const [matBaseColor, setMatBaseColor] = useState<string>("#e5e5e5")
  const [matMetalness, setMatMetalness] = useState<number>(1)
  const [matRoughness, setMatRoughness] = useState<number>(1)
  const [matClearcoat, setMatClearcoat] = useState<number>(0)
  const [matClearcoatRough, setMatClearcoatRough] = useState<number>(0.6)
  const [matIOR, setMatIOR] = useState<number>(1.5)
  const [matTransmission, setMatTransmission] = useState<number>(0)

  const [isOrbitControlsEnabled, setIsOrbitControlsEnabled] = useState(true)
  const modelRef = useRef<THREE.Group>(null)
  const captureControllerRef = useRef<{ capture: () => Promise<File | null> }>(null)
  const orbitControlsRef = useRef<OrbitControlsImpl>(null)
  const [boundsKey, setBoundsKey] = useState(0)
  const [isLightDragging, setIsLightDragging] = useState(false)

  const [groundEnabled, setGroundEnabled] = useState(false)
  const [groundY, setGroundY] = useState(0)

  const defaultLights: Light[] = useMemo(() => {
    const preset = lightingPresets.find((p) => p.name === "3-Point")?.lights ?? []
    return preset.map((l, i) => ({ ...l, id: Date.now() + i, visible: true }))
  }, [])

  const resetViewSettings = useCallback(
    (s: ViewSettings | null | undefined) => {
      setLights((s?.lights ?? defaultLights).map((l, i) => ({ ...l, id: Date.now() + i, visible: true })))
      setLightsEnabled(s?.lightsEnabled ?? true)
      setEnvironmentEnabled(s?.environmentEnabled ?? false)
      setBloomEnabled(s?.bloomEnabled ?? false)
      setBgType(s?.bgType ?? "color")
      setBgColor1(s?.bgColor1 ?? "#000000")
      setBgColor2(s?.bgColor2 ?? "#1a1a1a")
      setBgImage(s?.bgImage ?? null)
      setMaterialMode(s?.materialMode ?? "white")
      setFov(s?.fov ?? 50)
      setIsOrthographic(s?.orthographic ?? false)
      setMatOverrideEnabled(!!s?.materialOverride?.enabled)
      setMatBaseColor(s?.materialOverride?.color ?? "#e5e5e5")
      setMatMetalness(s?.materialOverride?.metalness ?? 1)
      setMatRoughness(s?.materialOverride?.roughness ?? 1)
      setMatClearcoat(s?.materialOverride?.clearcoat ?? 0)
      setMatClearcoatRough(s?.materialOverride?.clearcoatRoughness ?? 0.6)
      setMatIOR(s?.materialOverride?.ior ?? 1.5)
      setMatTransmission(s?.materialOverride?.transmission ?? 0)
      setSelectedLightId(null)
    },
    [defaultLights]
  )

  useEffect(() => {
    if (!selectedModel) return
    resetViewSettings(selectedModel.view_settings)
    setCameraPosition(selectedModel.view_settings?.cameraPosition || [5, 5, 5])
    setCameraTarget(selectedModel.view_settings?.cameraTarget || [0, 0, 0])
  }, [selectedModel, resetViewSettings])

  useEffect(() => {
    if (modelRef.current && selectedModel) {
      setGroundY(-0.001)

      if (!selectedModel.view_settings?.cameraPosition) {
        const box = new THREE.Box3().setFromObject(modelRef.current)
        const size = box.getSize(new THREE.Vector3())
        const center = box.getCenter(new THREE.Vector3())
        const maxDim = Math.max(size.x, size.y, size.z)

        const newPos: [number, number, number] = [center.x + maxDim, center.y + maxDim, center.z + maxDim]
        const newTgt: [number, number, number] = [center.x, center.y, center.z]

        setCameraPosition(newPos)
        setCameraTarget(newTgt)
      }
      setBoundsKey((k) => k + 1)
    }
  }, [selectedModel])

  const updateQuery = (params: Record<string, string | null>) => {
    const q = new URLSearchParams(searchParams.toString())
    Object.entries(params).forEach(([k, v]) => (v === null ? q.delete(k) : q.set(k, v)))
    router.push(`?${q.toString()}`)
  }

  const { mutate: mutateModel } = useSWRConfig()
  const handleModelUpdate = useCallback(
    async (id: string, updates: Partial<Omit<Model, "id" | "created_at">>) => {
      await fetch(`/api/models/${id}`, { method: "PATCH", headers: { "Content-Type": "application/json" }, body: JSON.stringify(updates) })
      mutateSelectedModel()
      mutate(galleryUrl)
      mutateModel(`/api/models/${id}`)
      setRefreshKey((k) => k + 1)
    },
    [mutateSelectedModel, mutate, mutateModel, galleryUrl]
  )

  const handleThumbnailUpload = useCallback(
    async (file: File) => {
      if (!selectedModel) return
      const fromName = file.name?.split(".").pop()?.toLowerCase()
      const fromType = (file.type || "").split("/")[1]
      const ext = (fromName || fromType || "png").replace(/[^a-z0-9]/gi, "")
      const pathname = `thumbnails/${selectedModel.id}-${Date.now()}.${ext || "png"}`
      try {
        const newBlob = await upload(pathname, file, { access: "public", handleUploadUrl: "/api/upload" })
        const url = (newBlob as any).url || (newBlob as any).downloadUrl
        await handleModelUpdate(selectedModel.id, { thumbnail_url: `${url}?v=${Date.now()}` })
      } catch {
        const fallback = URL.createObjectURL(file)
        await handleModelUpdate(selectedModel.id, { thumbnail_url: fallback })
      }
    },
    [selectedModel, handleModelUpdate]
  )

  const handleCaptureThumbnail = useCallback(async () => {
    if (!captureControllerRef.current) return
    const file = await captureControllerRef.current.capture()
    if (file) await handleThumbnailUpload(file)
  }, [handleThumbnailUpload])

  useEffect(() => {
    if (!selectedModel) return
    if (selectedModel.thumbnail_url.includes("/placeholder.svg")) {
      const t = setTimeout(() => captureControllerRef.current && handleCaptureThumbnail(), 1200)
      return () => clearTimeout(t)
    }
  }, [selectedModel, handleCaptureThumbnail])

  const handleModelClick = (m: Model) => updateQuery({ modelId: m.id })
  const handleCloseViewer = () => updateQuery({ modelId: null })

  const handleItemClick = (e: React.MouseEvent, item: Model & { type: "model" }) => {
    e.stopPropagation()
    const next = new Set(selectedItems)
    if (e.shiftKey && lastSelectedItem.current) {
      const li = filteredItems.findIndex((i) => i.id === lastSelectedItem.current)
      const ci = filteredItems.findIndex((i) => i.id === item.id)
      const [s, t] = [li, ci].sort((a, b) => a - b)
      for (let i = s; i <= t; i++) next.add(filteredItems[i].id)
    } else if (e.metaKey || e.ctrlKey) next.has(item.id) ? next.delete(item.id) : next.add(item.id)
    else {
      next.size === 1 && next.has(item.id) ? next.clear() : next.clear()
      next.add(item.id)
    }
    setSelectedItems(next)
    lastSelectedItem.current = item.id
  }

  const handleUploadAction = async (files: FileList | null) => {
    if (!files?.length) return
    await Promise.all(
      Array.from(files).map(async (file) => {
        if (!file.name.endsWith(".glb")) return
        try {
          const blob = await upload(file.name.replace(/\s+/g, "_"), file, { access: "public", handleUploadUrl: "/api/upload" })
          const url = (blob as any).url || (blob as any).downloadUrl
          await fetch("/api/models", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: file.name.replace(/\.glb$/, ""),
              model_url: url,
              thumbnail_url: `/placeholder.svg?width=400&height=400&query=${encodeURIComponent(file.name.replace(/\.glb$/, ""))}`,
              folder_id: currentFolderId
            })
          })
        } catch { }
      })
    )
    mutate(galleryUrl)
    setRefreshKey((k) => k + 1)
  }

  const handleRename = async (newName: string) => {
    const item = renameItem
    if (!item) return
    const url = `/api/models/${item.id}`
    await fetch(url, { method: "PATCH", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ name: newName }) })
    mutate(galleryUrl)
    mutate(`/api/models/${item.id}`)
    setRenameItem(null)
    setRefreshKey((k) => k + 1)
  }

  const bulkAct = async (ids: string[], fn: (id: string) => Promise<void>) => {
    await Promise.all(ids.map(async (id) => fn(id)))
    mutate(galleryUrl)
    setRefreshKey((k) => k + 1)
  }

  const handleBulkDelete = async () => {
    await bulkAct(Array.from(selectedItems), (id) => fetch(`/api/models/${id}`, { method: "DELETE" }).then(() => { }))
    if (Array.from(selectedItems).includes(modelId || "")) handleCloseViewer()
    setSelectedItems(new Set())
  }

  const handleBulkMove = async (_targetFolderId: string | null) => { }

  const handleBulkSetPublic = async (isPublic: boolean) => {
    await bulkAct(Array.from(selectedItems), (id) =>
      fetch(`/api/models/${id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ is_public: isPublic })
      }).then(() => { })
    )
    if (Array.from(selectedItems).includes(modelId || "")) mutateSelectedModel()
    setSelectedItems(new Set())
  }

  const handleSaveViewSettings = useCallback(async () => {
    if (!selectedModel) return
    const settings: ViewSettings = {
      lights: lights.map(({ id, visible, ...rest }) => rest),
      lightsEnabled,
      environmentEnabled,
      bloomEnabled,
      ssaoEnabled: false,
      bgType,
      bgColor1,
      bgColor2,
      bgImage,
      fov,
      orthographic: isOrthographic,
      cameraPosition,
      cameraTarget,
      materialMode,
      materialOverride: {
        enabled: matOverrideEnabled,
        color: matBaseColor,
        metalness: matMetalness,
        roughness: matRoughness,
        clearcoat: matClearcoat,
        clearcoatRoughness: matClearcoatRough,
        ior: matIOR,
        transmission: matTransmission
      }
    }
    await handleModelUpdate(selectedModel.id, { view_settings: settings })
  }, [
    selectedModel,
    lights,
    lightsEnabled,
    environmentEnabled,
    bloomEnabled,
    bgType,
    bgColor1,
    bgColor2,
    bgImage,
    fov,
    isOrthographic,
    cameraPosition,
    cameraTarget,
    materialMode,
    matOverrideEnabled,
    matBaseColor,
    matMetalness,
    matRoughness,
    matClearcoat,
    matClearcoatRough,
    matIOR,
    matTransmission,
    handleModelUpdate
  ])

  const handleDeleteViewSettings = async () => {
    if (!selectedModel) return
    await handleModelUpdate(selectedModel.id, { view_settings: null })
    resetViewSettings(null)
  }

  const handleDeleteThumbnail = async () => {
    if (!selectedModel) return
    const placeholder = `/placeholder.svg?width=400&height=400&query=${encodeURIComponent(selectedModel.name)}`
    await handleModelUpdate(selectedModel.id, { thumbnail_url: placeholder })
  }

  const randomizeAllPartial = () => ({
    intensity: 10 + Math.random() * 40,
    kelvin: 1500 + Math.random() * 10500,
    angle: 10 + Math.random() * 80,
    penumbra: Math.random()
  })
  const handleLightChange = (id: number, v: Partial<Omit<Light, "id">>) => setLights((ls) => ls.map((l) => (l.id === id ? { ...l, ...v } : l)))
  const addLight = () => {
    if (lights.length >= 5) return
    const nl: Light = {
      id: Date.now(),
      visible: true,
      position: [-2, 3, 2],
      targetPosition: [0, 0, 0],
      intensity: 3,
      kelvin: 5500,
      decay: 1,
      angle: 45,
      penumbra: 0.5
    }
    setLights((ls) => [...ls, nl])
    setSelectedLightId(nl.id)
  }
  const removeLight = (id: number) => {
    if (lights.length <= 1) return
    setLights((ls) => ls.filter((l) => l.id !== id))
    if (selectedLightId === id) setSelectedLightId(lights.find((l) => l.id !== id)?.id ?? null)
  }
  const toggleLightVisibility = (id: number) => setLights((ls) => ls.map((l) => (l.id === id ? { ...l, visible: !l.visible } : l)))
  const cloneLight = (id: number) => {
    if (lights.length >= 5) return
    const src = lights.find((l) => l.id === id)
    if (!src) return
    const nl = { ...src, id: Date.now(), position: [src.position[0] + 1, src.position[1], src.position[2]] as [number, number, number] }
    setLights((ls) => [...ls, nl])
    setSelectedLightId(nl.id)
  }
  const focusLightOnModel = (id: number) => {
    if (!modelRef.current) return
    const box = new THREE.Box3().setFromObject(modelRef.current),
      c = new THREE.Vector3()
    box.getCenter(c)
    handleLightChange(id, { targetPosition: [c.x, c.y, c.z] })
  }
  const applyPreset = (name: string) => {
    const p = lightingPresets.find((p) => p.name === name)
    if (!p) return
    setLights(p.lights.map((l, i) => ({ ...l, id: Date.now() + i, visible: true })))
    setSelectedLightId(null)
  }

  const onKey = useCallback(
    (e: KeyboardEvent) => {
      if (!modelId || document.activeElement instanceof HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement) return
      const k = e.key.toLowerCase()
      if (k === "1") setMaterialMode("white")
      if (k === "2") setMaterialMode("pbr")
      if (k === "3") setMaterialMode("normal")
      if (k === "f") {
        e.preventDefault()
        setBoundsKey((key) => key + 1)
      }
      if (k === "o") {
        e.preventDefault()
        setIsOrthographic((prev) => !prev)
        setBoundsKey((key) => key + 1)
      }
      if (k === "e") {
        e.preventDefault()
        setEnvironmentEnabled(true)
        setBgType("color")
        setBgColor1("#ffffff")
      }
      if (k === "t") {
        e.preventDefault()
          ; (async () => {
            await handleSaveViewSettings()
            await handleCaptureThumbnail()
          })()
      }
      if (k === "r") {
        e.preventDefault()
        selectedLightId === null ? setLights((ls) => ls.map((l) => ({ ...l, ...randomizeAllPartial() }))) : handleLightChange(selectedLightId, randomizeAllPartial())
      }
      if (k === "arrowright" || k === "arrowleft") {
        const ms = gridModels
        if (!ms.length) return
        const i = ms.findIndex((m) => m.id === modelId)
        if (i === -1) return
        const ni = k === "arrowright" ? (i + 1) % ms.length : (i - 1 + ms.length) % ms.length
        updateQuery({ modelId: ms[ni].id })
      }
    },
    [gridModels, modelId, selectedLightId, handleSaveViewSettings, handleCaptureThumbnail]
  )
  useEffect(() => {
    window.addEventListener("keydown", onKey)
    return () => window.removeEventListener("keydown", onKey)
  }, [onKey])

  const onPointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
    if (e.shiftKey && selectedLightId !== null) {
      e.stopPropagation()
      setIsLightDragging(true)
      setIsOrbitControlsEnabled(false)
        ; (e.target as HTMLElement).style.cursor = "grabbing"
    }
  }
  const onPointerMove = (e: React.PointerEvent<HTMLDivElement>) => {
    if (!isLightDragging || selectedLightId === null) return
    e.stopPropagation()
    const light = lights.find((l) => l.id === selectedLightId)
    if (!light || !orbitControlsRef.current) return
    const targetPos = new THREE.Vector3().fromArray(light.targetPosition)
    const vec = new THREE.Vector3().fromArray(light.position).sub(targetPos)
    const cam = orbitControlsRef.current.object
    const up = new THREE.Vector3(0, 1, 0).applyQuaternion(cam.quaternion)
    const rt = new THREE.Vector3(1, 0, 0).applyQuaternion(cam.quaternion)
    vec.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(up, -e.movementX * 0.005)).applyQuaternion(new THREE.Quaternion().setFromAxisAngle(rt, -e.movementY * 0.005))
    const pos = vec.add(targetPos)
    handleLightChange(selectedLightId, { position: pos.toArray() as [number, number, number] })
  }
  const onPointerUp = () => {
    if (!isLightDragging) return
    setIsLightDragging(false)
    setIsOrbitControlsEnabled(true)
    document.body.style.cursor = "auto"
  }

  const bgStyle: React.CSSProperties = useMemo(() => {
    if (!environmentEnabled) return { backgroundColor: "#000000" }
    if (bgType === "gradient") return { background: `linear-gradient(to bottom, ${bgColor1}, ${bgColor2})` }
    if (bgType === "image" && bgImage) return { backgroundImage: `url(${bgImage})`, backgroundSize: "cover", backgroundPosition: "center" }
    return { backgroundColor: bgColor1 }
  }, [environmentEnabled, bgType, bgColor1, bgColor2, bgImage])

  const [isNewFolderDialogOpen, setIsNewFolderDialogOpen] = useState(false)
  const [renameItem, setRenameItem] = useState<Model | null>(null)
  const [editingFolder, setEditingFolder] = useState<Folder | null>(null)

  const activeFilterCount = useMemo(() => {
    let n = 0
    if (filterVisibility !== "all") n++
    if (filterFolderIds.size > 0) n++
    if (filterDate !== "any") n++
    if (filterHasThumb !== "any") n++
    return n
  }, [filterVisibility, filterFolderIds, filterDate, filterHasThumb])

  const handleFeelingLucky = () => {
    if (filteredItems.length === 0) return
    const randomModel = filteredItems[Math.floor(Math.random() * filteredItems.length)]
    if (randomModel) {
      updateQuery({ modelId: randomModel.id })
    }
  }

  if (modelId) {
    if (!selectedModel) return <div className="w-full h-screen" />
    return (
      <div className="w-full h-screen relative" style={bgStyle}>
        <Canvas
          shadows
          gl={{ preserveDrawingBuffer: true, antialias: true, alpha: true }}
          onCreated={({ gl }) => {
            gl.setClearAlpha(0)
            gl.outputColorSpace = THREE.SRGBColorSpace
            gl.toneMapping = THREE.ACESFilmicToneMapping
            gl.toneMappingExposure = 1
            gl.shadowMap.enabled = true
            gl.shadowMap.type = THREE.PCFSoftShadowMap
              ; (gl as any).physicallyCorrectLights = true
          }}
          onPointerMissed={(e) => e.button === 0 && setSelectedLightId(null)}
          onPointerDown={onPointerDown}
          onPointerMove={onPointerMove}
          onPointerUp={onPointerUp}
          onPointerLeave={onPointerUp}
          frameloop={isLightDragging ? "always" : "demand"}
        >
          {isOrthographic ? (
            <OrthographicCamera makeDefault position={cameraPosition} zoom={50} />
          ) : (
            <PerspectiveCamera makeDefault fov={fov} position={cameraPosition} />
          )}
          <Suspense fallback={null}>
            {groundEnabled && (
              <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, groundY, 0]} receiveShadow>
                <planeGeometry args={[200, 200]} />
                <shadowMaterial transparent opacity={0.25} />
              </mesh>
            )}
            {lightsEnabled && lights.map((l) => <SpotLightInScene key={l.id} light={l} />)}
            <Bounds fit clip damping={6} margin={1.2} key={`${selectedModel.id}-${boundsKey}`}>
              <ModelViewer
                ref={modelRef}
                modelUrl={selectedModel.model_url}
                materialMode={materialMode}
                materialOverride={{
                  enabled: matOverrideEnabled,
                  color: matBaseColor,
                  metalness: matMetalness,
                  roughness: matRoughness,
                  clearcoat: matClearcoat,
                  clearcoatRoughness: matClearcoatRough,
                  ior: matIOR,
                  transmission: matTransmission
                }}
              />
            </Bounds>
            {bloomEnabled && (
              <EffectComposer disableNormalPass>
                <Bloom mipmapBlur intensity={0.5} luminanceThreshold={1} />
              </EffectComposer>
            )}
            <CaptureController ref={captureControllerRef} modelRef={modelRef} />
          </Suspense>
          <OrbitControls
            ref={orbitControlsRef}
            enabled={isOrbitControlsEnabled}
            target={cameraTarget}
            onChange={(e) => {
              if (e?.target) {
                setCameraPosition(e.target.object.position.toArray())
                setCameraTarget(e.target.target.toArray())
              }
            }}
          />
          <GizmoHelper alignment="bottom-right" margin={[80, 80]} key={isOrthographic ? "ortho" : "persp"}>
            <GizmoViewport axisColors={["#9d4b4b", "#2f7f4f", "#3b5b9d"]} labelColor="white" />
          </GizmoHelper>
          <ambientLight intensity={0.1} />
        </Canvas>

        <div className="absolute top-4 left-4 z-10">
          <Button variant="ghost" size="icon" onClick={handleCloseViewer} className="text-white bg-black/50 backdrop-blur-sm hover:bg-white/20 rounded-full">
            <ChevronLeft className="h-6 w-6" />
          </Button>
        </div>

        <div className="absolute top-4 right-4 w-[360px] bg-black/50 backdrop-blur-sm border border-white/20 rounded-lg text-white z-10 flex flex-col max-h-[calc(100vh-2rem)]">
          <div className="flex items-center justify-between p-4">
            <div className="flex items-center gap-2">
              <span className="text-xs">Ground</span>
              <Switch checked={groundEnabled} onCheckedChange={setGroundEnabled} />
            </div>
            <button onClick={() => setIsSettingsPanelOpen(!isSettingsPanelOpen)} className="p-1 -m-1">
              <ChevronDown className={`h-5 w-5 transition-transform ${isSettingsPanelOpen ? "rotate-180" : ""}`} />
            </button>
          </div>
          {isSettingsPanelOpen && (
            <SettingsPanel
              model={selectedModel}
              onUpdate={handleModelUpdate}
              onDelete={() => {
                setSelectedItems(new Set([selectedModel.id]))
                handleBulkDelete()
              }}
              onThumbnailUpload={handleThumbnailUpload}
              onCaptureThumbnail={handleCaptureThumbnail}
              onDeleteThumbnail={handleDeleteThumbnail}
              lights={lights}
              onLightChange={handleLightChange}
              addLight={addLight}
              removeLight={removeLight}
              cloneLight={cloneLight}
              toggleLightVisibility={toggleLightVisibility}
              selectedLightId={selectedLightId}
              onSelectLight={setSelectedLightId}
              onFocusLight={focusLightOnModel}
              lightsEnabled={lightsEnabled}
              onLightsEnabledChange={setLightsEnabled}
              environmentEnabled={environmentEnabled}
              onEnvironmentEnabledChange={setEnvironmentEnabled}
              bloomEnabled={bloomEnabled}
              onBloomEnabledChange={setBloomEnabled}
              bgType={bgType}
              onBgTypeChange={setBgType}
              bgColor1={bgColor1}
              onBgColor1Change={setBgColor1}
              bgColor2={bgColor2}
              onBgColor2Change={setBgColor2}
              bgImage={bgImage}
              onBgImageChange={setBgImage}
              materialMode={materialMode}
              onMaterialModeChange={setMaterialMode}
              fov={fov}
              onFovChange={setFov}
              isOrthographic={isOrthographic}
              onIsOrthographicChange={setIsOrthographic}
              matOverrideEnabled={matOverrideEnabled}
              onMatOverrideEnabledChange={setMatOverrideEnabled}
              matBaseColor={matBaseColor}
              onMatBaseColorChange={setMatBaseColor}
              matMetalness={matMetalness}
              onMatMetalnessChange={setMatMetalness}
              matRoughness={matRoughness}
              onMatRoughnessChange={setMatRoughness}
              matClearcoat={matClearcoat}
              onMatClearcoatChange={setMatClearcoat}
              matClearcoatRoughness={matClearcoatRough}
              onMatClearcoatRoughnessChange={setMatClearcoatRough}
              matIOR={matIOR}
              onMatIORChange={setMatIOR}
              matTransmission={matTransmission}
              onMatTransmissionChange={setMatTransmission}
              onSaveView={handleSaveViewSettings}
              onDeleteView={handleDeleteViewSettings}
              onResetView={() => resetViewSettings(selectedModel.view_settings)}
              onApplyPreset={(n) => applyPreset(n)}
              presets={lightingPresets.map((p) => p.name)}
            />
          )}
        </div>

        <div className="absolute bottom-4 left-1/2 -translate-x-1/2 bg-black/50 backdrop-blur-sm p-2 rounded-full flex items-center gap-1">
          <Button variant={materialMode === "white" ? "secondary" : "ghost"} size="icon" onClick={() => setMaterialMode("white")} className="text-white rounded-full">
            <div className="w-6 h-6 rounded-full bg-white" />
          </Button>
          <Button variant={materialMode === "pbr" ? "secondary" : "ghost"} size="icon" onClick={() => setMaterialMode("pbr")} className="text-white rounded-full">
            <Palette />
          </Button>
          <Button variant={materialMode === "normal" ? "secondary" : "ghost"} size="icon" onClick={() => setMaterialMode("normal")} className="text-white rounded-full">
            <div className="w-6 h-6 rounded-full bg-gradient-to-br from-red-500 via-green-500 to-blue-500" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            onClick={() => {
              const a = document.createElement("a")
              a.href = selectedModel.model_url
              a.download = `${selectedModel.name}.glb`
              document.body.appendChild(a)
              a.click()
              document.body.removeChild(a)
            }}
            className="text-white rounded-full"
          >
            <Download />
          </Button>
        </div>
      </div>
    )
  }

  return (
    <div className="h-screen bg-black text-white relative flex flex-col">
      <div className="flex items-center justify-between px-4 md:px-8 py-4">
        <div className="text-sm text-white/70">
          {breadcrumbs.map((c, i) => (
            <Fragment key={c.id ?? "root"}>
              <span className={i === breadcrumbs.length - 1 ? "text-white" : "text-white/60"}>{c.name}</span>
              {i < breadcrumbs.length - 1 && <span className="mx-1 text-white/30">/</span>}
            </Fragment>
          ))}
          {gallery?.currentFolder && (
            <Button variant="ghost" size="icon" className="h-6 w-6 ml-2" onClick={() => setEditingFolder(gallery.currentFolder)}>
              <Info className="h-4 w-4" />
            </Button>
          )}
        </div>
        <div className="flex items-center gap-2">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="icon" className="h-8 w-8 border-white/20 bg-transparent">
                <ListFilter className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>Sort by</DropdownMenuLabel>
              <DropdownMenuRadioGroup value={sortOption} onValueChange={setSortOption}>
                <DropdownMenuRadioItem value="created_at-desc">Newest</DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="created_at-asc">Oldest</DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="updated_at-desc">Recently updated</DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="name-asc">Name (A–Z)</DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="name-desc">Name (Z–A)</DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="visibility-desc">Visibility</DropdownMenuRadioItem>
              </DropdownMenuRadioGroup>
            </DropdownMenuContent>
          </DropdownMenu>

          <Button variant="secondary" size="icon" className="h-8 w-8 rounded-full" onClick={() => document.querySelector<HTMLInputElement>('input[type="file"]')?.click()}>
            <Plus className="h-4 w-4" />
          </Button>
        </div>
      </div>

      <div className={cn("px-4 md:px-8", filteredItems.length === 0 && !searchQuery ? "pt-24" : "pt-6")}>
        <div className={cn("mx-auto", filteredItems.length === 0 && !searchQuery ? "max-w-2xl" : "max-w-4xl")}>
          <div className={cn("relative", filteredItems.length === 0 && !searchQuery ? "" : "mb-4")}>
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-white/50" />
            <Input
              type="search"
              placeholder="Search for models, or tags..."
              className="pl-11 pr-12 h-12 rounded-full bg-white/10 border-white/20 text-white placeholder:text-white/60"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
            <Button
              variant="ghost"
              size="icon"
              className="absolute right-2 top-1/2 -translate-y-1/2 h-8 w-8 text-white/60 hover:text-white"
              onClick={handleFeelingLucky}
              title="I'm Feeling Lucky"
            >
              <Dice5 className="h-5 w-5" />
            </Button>
          </div>

          <div className="flex items-center justify-between gap-2 flex-wrap mt-4">
            <div className="flex items-center gap-2 flex-wrap">
              {(["all", "models", "public", "drafts"] as Pill[]).map((k) => (
                <button
                  key={k}
                  className={cn("px-3 py-1.5 rounded-full text-sm", pill === k ? "bg-white text-black" : "bg-white/10 text-white/80 hover:bg-white/20")}
                  onClick={() => setPill(k)}
                >
                  {k === "all" ? "All" : k[0].toUpperCase() + k.slice(1)}
                </button>
              ))}
            </div>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" className="h-8 px-3 border-white/20 bg-transparent flex items-center gap-2">
                  <ListFilter className="h-4 w-4" />
                  Filters{activeFilterCount > 0 && <span className="ml-1 rounded-full bg-white text-black text-xs px-2 py-0.5">{activeFilterCount}</span>}
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="w-72">
                <DropdownMenuLabel>Visibility</DropdownMenuLabel>
                <DropdownMenuRadioGroup value={filterVisibility} onValueChange={(v: any) => setFilterVisibility(v)}>
                  <DropdownMenuRadioItem value="all">All</DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="public">Public</DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="private">Private</DropdownMenuRadioItem>
                </DropdownMenuRadioGroup>
                <DropdownMenuSeparator />
                <DropdownMenuLabel>Folder</DropdownMenuLabel>
                <div className="max-h-60 overflow-y-auto px-1">
                  {(allFolders ?? []).map((f) => (
                    <DropdownMenuCheckboxItem
                      key={f.id}
                      checked={filterFolderIds.has(f.id)}
                      onSelect={(e) => e.preventDefault()}
                      onCheckedChange={(checked) => {
                        const newSet = new Set(filterFolderIds)
                        if (checked) {
                          newSet.add(f.id)
                        } else {
                          newSet.delete(f.id)
                        }
                        setFilterFolderIds(newSet)
                      }}
                    >
                      {f.name}
                    </DropdownMenuCheckboxItem>
                  ))}
                </div>
                <DropdownMenuSeparator />
                <DropdownMenuLabel>Date</DropdownMenuLabel>
                <DropdownMenuRadioGroup value={filterDate} onValueChange={(v: any) => setFilterDate(v)}>
                  <DropdownMenuRadioItem value="any">Any time</DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="24h">Last 24 hours</DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="7d">Last 7 days</DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="30d">Last 30 days</DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="365d">Last year</DropdownMenuRadioItem>
                </DropdownMenuRadioGroup>
                <DropdownMenuSeparator />
                <DropdownMenuLabel>Thumbnails</DropdownMenuLabel>
                <DropdownMenuRadioGroup value={filterHasThumb} onValueChange={(v: any) => setFilterHasThumb(v)}>
                  <DropdownMenuRadioItem value="any">Any</DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="yes">Has thumbnail</DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="no">Missing thumbnail</DropdownMenuRadioItem>
                </DropdownMenuRadioGroup>
                <DropdownMenuSeparator />
                <DropdownMenuCheckboxItem
                  checked={false}
                  onCheckedChange={() => {
                    setFilterVisibility("all")
                    setFilterFolderIds(new Set())
                    setFilterDate("any")
                    setFilterHasThumb("any")
                  }}
                >
                  Clear filters
                </DropdownMenuCheckboxItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>

      <main
        className="relative flex-1 overflow-y-auto px-4 md:px-8 pb-24"
        onClick={() => setSelectedItems(new Set())}
        onDrop={(e) => {
          e.preventDefault()
          handleUploadAction(e.dataTransfer.files)
        }}
        onDragOver={(e) => e.preventDefault()}
      >
        <input type="file" className="hidden" multiple accept=".glb" onChange={(e) => handleUploadAction(e.target.files)} />

        {isLoading && (
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-6 gap-4 mt-6">
            {Array.from({ length: 18 }).map((_, i) => (
              <Skeleton key={i} className="aspect-square rounded-lg bg-white/10" />
            ))}
          </div>
        )}

        {error && <div className="text-center text-destructive mt-12">Failed to load gallery.</div>}

        {!isLoading && filteredItems.length === 0 && searchQuery && <div className="text-center text-white/60 mt-10">No results.</div>}

        {!isLoading && filteredItems.length > 0 && (
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-6 gap-4 mt-6">
            {filteredItems.map((item) => (
              <ItemContextMenu
                key={item.id}
                item={item as unknown as GalleryItem}
                onRename={() => setRenameItem(item)}
                onDelete={() => {
                  setSelectedItems(new Set([item.id]))
                  handleBulkDelete()
                }}
                onMove={handleBulkMove}
                onSetPublic={(p) => {
                  setSelectedItems(new Set([item.id]))
                  handleBulkSetPublic(p)
                }}
                allFolders={allFolders}
              >
                <div
                  onClick={(e) => handleItemClick(e, item)}
                  onDoubleClick={() => handleModelClick(item)}
                  className={cn(
                    "group relative aspect-square rounded-lg overflow-hidden cursor-pointer transition-all duration-200 bg-white/5",
                    selectedItems.has(item.id) && "ring-2 ring-white ring-offset-[3px] ring-offset-black"
                  )}
                >
                  <>
                    <img
                      src={item.thumbnail_url || "/placeholder.svg"}
                      alt={item.name}
                      className="w-full h-full object-contain transition-transform duration-300 group-hover:scale-110"
                      onError={(e) => {
                        ; (e.target as HTMLImageElement).src = `/placeholder.svg?width=400&height=400&query=error`
                      }}
                    />
                    <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex items-end p-2">
                      <p className="text-sm font-semibold truncate text-white">{item.name}</p>
                    </div>
                  </>
                  <div className={cn("absolute top-2 left-2 transition-opacity", selectedItems.has(item.id) ? "opacity-100" : "opacity-0 group-hover:opacity-100")}>
                    <Checkbox
                      checked={selectedItems.has(item.id)}
                      onCheckedChange={(c) => {
                        const next = new Set(selectedItems)
                        c ? next.add(item.id) : next.delete(item.id)
                        setSelectedItems(next)
                      }}
                      className="bg-black/50 border-white/50 data-[state=checked]:bg-white data-[state=checked]:text-black"
                    />
                  </div>
                  <div className="absolute bottom-2 left-2">{item.is_public ? <Globe className="h-4 w-4 text-white/70" /> : <Lock className="h-4 w-4 text-white/70" />}</div>
                </div>
              </ItemContextMenu>
            ))}
            <div
              onClick={() => document.querySelector<HTMLInputElement>('input[type="file"]')?.click()}
              className="group relative aspect-square rounded-lg border-2 border-dashed border-white/20 flex flex-col items-center justify-center text-white/60 hover:bg-white/5 hover:border-white/40 transition-colors cursor-pointer"
            >
              <Upload className="w-1/3 h-1/3 transition-transform group-hover:scale-110" />
              <p className="text-sm font-semibold mt-2">Upload Models</p>
            </div>
          </div>
        )}
      </main>

      {selectedItems.size > 0 && (
        <BulkActionBar
          selectedCount={selectedItems.size}
          onClear={() => setSelectedItems(new Set())}
          onDelete={handleBulkDelete}
          onMove={handleBulkMove}
          onSetPublic={handleBulkSetPublic}
          onDownload={() => {
            const models = Array.from(selectedItems)
              .map((id) => gridModels.find((i) => i.id === id))
              .filter((i): i is Model & { type: "model" } => !!i)
            models.forEach((m) => {
              const a = document.createElement("a")
              a.href = m.model_url
              a.download = `${m.name}.glb`
              document.body.appendChild(a)
              a.click()
              document.body.removeChild(a)
            })
          }}
          allItems={gridModels as unknown as GalleryItem[]}
          selectedIds={selectedItems}
          allFolders={allFolders}
          currentFolderId={currentFolderId}
        />
      )}

      <NewFolderDialog
        open={isNewFolderDialogOpen}
        onOpenChange={setIsNewFolderDialogOpen}
        onCreate={async (name) => {
          await fetch("/api/folders", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ name, parent_id: currentFolderId }) })
          mutate(galleryUrl)
          setRefreshKey((k) => k + 1)
        }}
      />
      {renameItem && <RenameDialog item={renameItem} onOpenChange={() => setRenameItem(null)} onRename={handleRename} />}
      {editingFolder && (
        <FolderDescriptionDialog
          folder={editingFolder}
          open={!!editingFolder}
          onOpenChange={() => setEditingFolder(null)}
          onSave={(d) => {
            fetch(`/api/folders/${editingFolder.id}`, { method: "PATCH", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ description: d }) }).then(() => mutate(galleryUrl))
          }}
        />
      )}
    </div>
  )
}


=== /workspaces/space.iverfinne.no/components/gallery/bulk-action-bar.tsx ===

"use client"

import { Button } from "@/components/ui/button"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"
import type { Folder, GalleryItem } from "@/types"
import { Download, FolderIcon, FolderSymlink, Globe, Lock, Trash2, X } from "lucide-react"

interface Props {
    selectedCount: number
    onClear: () => void
    onDelete: () => void
    onMove: (targetFolderId: string | null) => void
    onSetPublic: (isPublic: boolean) => void
    onDownload: () => void
    allItems: GalleryItem[]
    selectedIds: Set<string>
    allFolders?: Folder[]
    currentFolderId: string | null
}

export function BulkActionBar({ selectedCount, onClear, onDelete, onMove, onSetPublic, onDownload, allItems, selectedIds, allFolders, currentFolderId }: Props) {
    const canDownload = allItems.filter((i) => selectedIds.has(i.id)).every((i) => i.type === "model")
    return (
        <div className="absolute bottom-0 left-0 right-0 bg-background border-t p-2 flex items-center justify-between z-20">
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="icon" onClick={onClear}><X className="h-5 w-5" /></Button>
                <span className="font-semibold">{selectedCount} selected</span>
            </div>
            <div className="flex items-center gap-2">
                <DropdownMenu>
                    <DropdownMenuTrigger asChild><Button variant="ghost" size="icon"><FolderSymlink className="h-4 w-4" /></Button></DropdownMenuTrigger>
                    <DropdownMenuContent>
                        <DropdownMenuItem onSelect={() => onMove(null)} disabled={currentFolderId === null}><FolderIcon className="mr-2 h-4 w-4" /> Assets (Root)</DropdownMenuItem>
                        {allFolders?.filter((f) => f.id !== currentFolderId).map((folder) => (
                            <DropdownMenuItem key={folder.id} onSelect={() => onMove(folder.id)}><FolderIcon className="mr-2 h-4 w-4" /> {folder.name}</DropdownMenuItem>
                        ))}
                    </DropdownMenuContent>
                </DropdownMenu>
                <Button variant="ghost" size="icon" onClick={() => onSetPublic(true)}><Globe className="h-4 w-4" /></Button>
                <Button variant="ghost" size="icon" onClick={() => onSetPublic(false)}><Lock className="h-4 w-4" /></Button>
                {canDownload && <Button variant="ghost" size="icon" onClick={onDownload}><Download className="h-4 w-4" /></Button>}
                <Button variant="ghost" size="icon" onClick={onDelete}><Trash2 className="h-4 w-4" /></Button>
            </div>
        </div>
    )
}


=== /workspaces/space.iverfinne.no/components/gallery/settings-panel.tsx ===

﻿"use client"

import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Slider } from "@/components/ui/slider"
import { Switch } from "@/components/ui/switch"
import type { Light, Model } from "@/types"
import { useGesture } from "@use-gesture/react"
import { Camera, CopyIcon as Clone, Crosshair, Eye, EyeOff, Globe, Lock, Plus, RotateCcw, Save, Trash2, Upload } from "lucide-react"
import React, { useRef, useState } from "react"

function EditableValue({
    value,
    onSave,
    units = "",
    className,
    inputClassName
}: {
    value: string | number
    onSave: (newValue: string) => void
    units?: string
    className?: string
    inputClassName?: string
}) {
    const [isEditing, setIsEditing] = useState(false)
    const [currentValue, setCurrentValue] = useState(value.toString())
    const inputRef = useRef<HTMLInputElement>(null)
    React.useEffect(() => setCurrentValue(value.toString()), [value])
    React.useEffect(() => {
        if (isEditing) inputRef.current?.select()
    }, [isEditing])
    const handleSave = () => {
        onSave(currentValue)
        setIsEditing(false)
    }
    return isEditing ? (
        <Input
            ref={inputRef}
            type="text"
            value={currentValue}
            onChange={(e) => setCurrentValue(e.target.value)}
            onBlur={handleSave}
            onKeyDown={(e) => {
                if (e.key === "Enter") handleSave()
                if (e.key === "Escape") setIsEditing(false)
            }}
            className={`h-6 text-xs w-full text-right bg-white/20 border-white/30 ${inputClassName ?? ""}`}
        />
    ) : (
        <span
            onClick={() => setIsEditing(true)}
            className={`cursor-pointer text-xs w-full text-right truncate ${className ?? ""}`}
            title={typeof value === "number" ? (value as number).toFixed(2) : (value as string)}
        >
            {typeof value === "number" ? (value as number).toFixed(units === "K" ? 0 : 1) : value}
            {units}
        </span>
    )
}

function DirectionalPad({ value, onChange }: { value: { x: number; z: number }; onChange: (v: { x: number; z: number }) => void }) {
    const padRef = useRef<HTMLDivElement>(null)
    const bind = useGesture(
        {
            onDrag: ({ xy }) => {
                if (!padRef.current) return
                const rect = padRef.current.getBoundingClientRect(),
                    half = rect.width / 2
                let x = xy[0] - rect.left - half,
                    z = xy[1] - rect.top - half
                const d = Math.hypot(x, z)
                if (d > half) {
                    x = (x / d) * half
                    z = (z / d) * half
                }
                onChange({ x: (x / half) * 5, z: (z / half) * 5 })
            }
        },
        { drag: { filterTaps: true } }
    )
    const handleX = (value.x / 5) * 50,
        handleZ = (value.z / 5) * 50
    return (
        <div ref={padRef} {...bind()} className="w-24 h-24 bg-white/10 rounded-full relative cursor-pointer border border-white/20 flex items-center justify-center">
            <div className="w-full h-px bg-white/20 absolute" />
            <div className="h-full w-px bg-white/20 absolute" />
            <div className="w-4 h-4 rounded-full absolute border-2 border-white bg-blue-500" style={{ transform: `translate(${handleX}px, ${handleZ}px)`, touchAction: "none" }} />
        </div>
    )
}

function LightSettings({ light, onLightChange, onFocus }: { light: Light; onLightChange: (id: number, newValues: Partial<Omit<Light, "id">>) => void; onFocus: (id: number) => void }) {
    return (
        <div className="space-y-3 text-xs mt-2 bg-white/5 p-3 rounded-md">
            <div className="flex items-center justify-between">
                <label>Position (X, Y, Z)</label>
                <div className="flex gap-1 w-1/2">
                    <EditableValue value={light.position[0]} onSave={(v) => onLightChange(light.id, { position: [Number(v), light.position[1], light.position[2]] })} />
                    <EditableValue value={light.position[1]} onSave={(v) => onLightChange(light.id, { position: [light.position[0], Number(v), light.position[2]] })} />
                    <EditableValue value={light.position[2]} onSave={(v) => onLightChange(light.id, { position: [light.position[0], light.position[1], Number(v)] })} />
                </div>
            </div>
            <div className="flex items-start justify-between">
                <div className="pt-2 space-y-2">
                    <label>Target</label>
                    <Button size="icon" className="text-xs h-6 w-6" variant="ghost" onClick={() => onFocus(light.id)}>
                        <Crosshair className="h-3 w-3" />
                    </Button>
                </div>
                <DirectionalPad value={{ x: light.targetPosition[0], z: light.targetPosition[2] }} onChange={({ x, z }) => onLightChange(light.id, { targetPosition: [x, light.targetPosition[1], z] })} />
            </div>
            <div className="flex items-center justify-between">
                <label>Target Height (Y)</label>
                <Slider value={[light.targetPosition[1]]} onValueChange={([v]) => onLightChange(light.id, { targetPosition: [light.targetPosition[0], v, light.targetPosition[2]] })} min={-10} max={10} step={0.1} className="w-1/2" />
            </div>
            <div className="flex items-center justify-between">
                <label>Intensity</label>
                <Slider value={[light.intensity]} onValueChange={([v]) => onLightChange(light.id, { intensity: v })} min={0} max={250} step={0.1} className="w-1/2" />
            </div>
            <div className="flex items-center justify-between">
                <label>Color Temp</label>
                <Slider value={[light.kelvin]} onValueChange={([v]) => onLightChange(light.id, { kelvin: v })} min={1000} max={12000} step={100} className="w-1/2" />
            </div>
            <div className="flex items-center justify-between">
                <label>Cone Angle</label>
                <Slider value={[light.angle]} onValueChange={([v]) => onLightChange(light.id, { angle: v })} min={0} max={90} step={1} className="w-1/2" />
            </div>
            <div className="flex items-center justify-between">
                <label>Penumbra</label>
                <Slider value={[light.penumbra]} onValueChange={([v]) => onLightChange(light.id, { penumbra: v })} min={0} max={1} step={0.01} className="w-1/2" />
            </div>
            <div className="flex items-center justify-between">
                <label>Distance</label>
                <Slider value={[light.distance ?? 0]} onValueChange={([v]) => onLightChange(light.id, { distance: v })} min={0} max={20} step={0.1} className="w-1/2" />
            </div>
        </div>
    )
}

export interface SettingsPanelProps {
    model: Model
    onUpdate: (id: string, updates: Partial<Omit<Model, "id" | "created_at">>) => void
    onDelete: () => void
    onThumbnailUpload: (file: File) => void
    onCaptureThumbnail: () => void
    onDeleteThumbnail: () => void
    lights: Light[]
    onLightChange: (id: number, newValues: Partial<Omit<Light, "id">>) => void
    addLight: () => void
    removeLight: (id: number) => void
    cloneLight: (id: number) => void
    toggleLightVisibility: (id: number) => void
    selectedLightId: number | null
    onSelectLight: (id: number | null) => void
    onFocusLight: (id: number) => void
    lightsEnabled: boolean
    onLightsEnabledChange: (enabled: boolean) => void
    environmentEnabled: boolean
    onEnvironmentEnabledChange: (enabled: boolean) => void
    bloomEnabled: boolean
    onBloomEnabledChange: (enabled: boolean) => void
    bgType: "color" | "gradient" | "image"
    onBgTypeChange: (type: "color" | "gradient" | "image") => void
    bgColor1: string
    onBgColor1Change: (value: string) => void
    bgColor2: string
    onBgColor2Change: (value: string) => void
    bgImage: string | null
    onBgImageChange: (value: string | null) => void
    materialMode: "pbr" | "normal" | "white"
    onMaterialModeChange: (m: "pbr" | "normal" | "white") => void
    fov: number
    onFovChange: (v: number) => void
    isOrthographic: boolean
    onIsOrthographicChange: (v: boolean) => void
    matOverrideEnabled: boolean
    onMatOverrideEnabledChange: (v: boolean) => void
    matBaseColor: string
    onMatBaseColorChange: (v: string) => void
    matMetalness: number
    onMatMetalnessChange: (v: number) => void
    matRoughness: number
    onMatRoughnessChange: (v: number) => void
    matClearcoat: number
    onMatClearcoatChange: (v: number) => void
    matClearcoatRoughness: number
    onMatClearcoatRoughnessChange: (v: number) => void
    matIOR: number
    onMatIORChange: (v: number) => void
    matTransmission: number
    onMatTransmissionChange: (v: number) => void
    onSaveView: () => void
    onDeleteView: () => void
    onResetView: () => void
    onApplyPreset: (name: string) => void
    presets: string[]
}

export function SettingsPanel(p: SettingsPanelProps) {
    const {
        model,
        onUpdate,
        onDelete,
        onThumbnailUpload,
        onCaptureThumbnail,
        onDeleteThumbnail,
        lights,
        onLightChange,
        addLight,
        removeLight,
        cloneLight,
        toggleLightVisibility,
        selectedLightId,
        onSelectLight,
        onFocusLight,
        lightsEnabled,
        onLightsEnabledChange,
        environmentEnabled,
        onEnvironmentEnabledChange,
        bloomEnabled,
        onBloomEnabledChange,
        bgType,
        onBgTypeChange,
        bgColor1,
        onBgColor1Change,
        bgColor2,
        onBgColor2Change,
        bgImage,
        onBgImageChange,
        materialMode,
        onMaterialModeChange,
        fov,
        onFovChange,
        isOrthographic,
        onIsOrthographicChange,
        matOverrideEnabled,
        onMatOverrideEnabledChange,
        matBaseColor,
        onMatBaseColorChange,
        matMetalness,
        onMatMetalnessChange,
        matRoughness,
        onMatRoughnessChange,
        matClearcoat,
        onMatClearcoatChange,
        matClearcoatRoughness,
        onMatClearcoatRoughnessChange,
        matIOR,
        onMatIORChange,
        matTransmission,
        onMatTransmissionChange,
        onSaveView,
        onDeleteView,
        onResetView,
        onApplyPreset,
        presets
    } = p

    const [preset, setPreset] = useState<string>(presets[0] ?? "")
    const thumbnailInputRef = useRef<HTMLInputElement>(null)
    const bgImageInputRef = useRef<HTMLInputElement>(null)
    const [lightsSectionOpen, setLightsSectionOpen] = useState(false)

    const handleBgImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0]
        if (!file) return
        const r = new FileReader()
        r.onloadend = () => onBgImageChange(r.result as string)
        r.readAsDataURL(file)
    }

    return (
        <div className="px-4 pb-4 flex flex-col h-full text-white overflow-y-auto">
            <div className="space-y-4 flex-1 overflow-y-auto pr-2 -mr-2">
                <div className="space-y-2">
                    <div className="flex items-center justify-between text-xs">
                        <label>Name</label>
                        <div className="w-1/2">
                            <EditableValue value={model.name} onSave={(v) => onUpdate(model.id, { name: v })} />
                        </div>
                    </div>
                    <div className="flex items-center justify-between text-xs">
                        <label>Visibility</label>
                        <Button size="sm" className="h-6 bg-transparent" variant="outline" onClick={() => onUpdate(model.id, { is_public: !model.is_public })}>
                            {model.is_public ? <Globe className="h-3 w-3 mr-1" /> : <Lock className="h-3 w-3 mr-1" />}
                            {model.is_public ? "Public" : "Private"}
                        </Button>
                    </div>
                    <div className="flex items-center justify-between text-xs">
                        <label>Thumbnail</label>
                        <div className="flex items-center gap-1">
                            <Button variant="ghost" size="icon" className="h-6 w-6" disabled={model.thumbnail_url.includes("/placeholder.svg")} onClick={onDeleteThumbnail}>
                                <Trash2 className="h-3 w-3" />
                            </Button>
                            <Button size="icon" className="h-6 w-6" variant="ghost" onClick={onCaptureThumbnail}>
                                <Camera className="h-3 w-3" />
                            </Button>
                            <Button size="icon" className="h-6 w-6" variant="ghost" onClick={() => thumbnailInputRef.current?.click()}>
                                <Upload className="h-3 w-3" />
                            </Button>
                            <input type="file" ref={thumbnailInputRef} className="hidden" accept="image/*" onChange={(e) => e.target.files && onThumbnailUpload(e.target.files[0])} />
                        </div>
                    </div>
                    <div className="flex items-center justify-between text-xs">
                        <label>Delete Model</label>
                        <Button variant="ghost" size="sm" className="h-6" onClick={onDelete}>
                            Delete
                        </Button>
                    </div>
                </div>

                <Separator className="bg-white/20" />

                <div className="space-y-3">
                    <h3 className="text-sm font-semibold">Camera</h3>
                    <div className="space-y-2 bg-white/5 p-3 rounded-md">
                        <div className="flex items-center justify-between text-xs">
                            <label>Orthographic</label>
                            <Switch checked={isOrthographic} onCheckedChange={onIsOrthographicChange} />
                        </div>
                        {!isOrthographic && (
                            <div className="flex items-center justify-between text-xs">
                                <label>Field of View</label>
                                <Slider value={[fov]} onValueChange={([v]) => onFovChange(v)} min={10} max={120} step={1} className="w-2/3" />
                            </div>
                        )}
                    </div>
                </div>

                <Separator className="bg-white/20" />

                <div className="space-y-3">
                    <div className="flex items-center justify-between">
                        <h3 className="text-sm font-semibold">Material</h3>
                        <div className="flex items-center gap-2">
                            <Select value={materialMode} onValueChange={(v: any) => onMaterialModeChange(v)}>
                                <SelectTrigger className="h-6 text-xs bg-white/10 border-white/30 w-28">
                                    <SelectValue placeholder="Mode" />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value="white">White</SelectItem>
                                    <SelectItem value="pbr">PBR</SelectItem>
                                    <SelectItem value="normal">Normal</SelectItem>
                                </SelectContent>
                            </Select>
                        </div>
                    </div>

                    <div className="space-y-2 bg-white/5 p-3 rounded-md">
                        <div className="flex items-center justify-between text-xs">
                            <label>Override</label>
                            <Switch checked={matOverrideEnabled} onCheckedChange={onMatOverrideEnabledChange} />
                        </div>

                        {matOverrideEnabled && (
                            <>
                                <div className="flex items-center justify-between text-xs">
                                    <label>Base Color</label>
                                    <input type="color" value={matBaseColor} onChange={(e) => onMatBaseColorChange(e.target.value)} className="w-6 h-6 p-0 bg-transparent border-none" />
                                </div>
                                <div className="flex items-center justify-between text-xs">
                                    <label>Metallic</label>
                                    <Slider value={[matMetalness]} onValueChange={([v]) => onMatMetalnessChange(v)} min={0} max={1} step={0.01} className="w-2/3" />
                                </div>
                                <div className="flex items-center justify-between text-xs">
                                    <label>Roughness</label>
                                    <Slider value={[matRoughness]} onValueChange={([v]) => onMatRoughnessChange(v)} min={0} max={1} step={0.01} className="w-2/3" />
                                </div>
                                <div className="flex items-center justify-between text-xs">
                                    <label>Clearcoat</label>
                                    <Slider value={[matClearcoat]} onValueChange={([v]) => onMatClearcoatChange(v)} min={0} max={1} step={0.01} className="w-2/3" />
                                </div>
                                <div className="flex items-center justify-between text-xs">
                                    <label>Clearcoat Rough.</label>
                                    <Slider value={[matClearcoatRoughness]} onValueChange={([v]) => onMatClearcoatRoughnessChange(v)} min={0} max={1} step={0.01} className="w-2/3" />
                                </div>
                                <div className="flex items-center justify-between text-xs">
                                    <label>IOR</label>
                                    <Slider value={[matIOR]} onValueChange={([v]) => onMatIORChange(v)} min={1} max={2.333} step={0.01} className="w-2/3" />
                                </div>
                                <div className="flex items-center justify-between text-xs">
                                    <label>Transmission</label>
                                    <Slider value={[matTransmission]} onValueChange={([v]) => onMatTransmissionChange(v)} min={0} max={1} step={0.01} className="w-2/3" />
                                </div>
                            </>
                        )}
                    </div>
                </div>

                <Separator className="bg-white/20" />

                <div className="space-y-3">
                    <div className="flex items-center justify-between cursor-pointer" onClick={() => setLightsSectionOpen((s) => !s)}>
                        <h3 className="text-sm font-semibold">Lights</h3>
                        <div className="flex items-center gap-2">
                            <Switch checked={lightsEnabled} onCheckedChange={onLightsEnabledChange} />
                            <span className={`transition-transform ${lightsSectionOpen ? "rotate-180" : ""}`}>⌄</span>
                        </div>
                    </div>
                    {lightsEnabled && lightsSectionOpen && (
                        <>
                            <div className="flex items-center justify-between text-xs">
                                <label>Presets</label>
                                <div className="flex items-center gap-2 w-1/2">
                                    <Select value={preset} onValueChange={setPreset}>
                                        <SelectTrigger className="h-6 text-xs bg-white/10 border-white/30 w-2/3">
                                            <SelectValue placeholder="Choose preset" />
                                        </SelectTrigger>
                                        <SelectContent>{presets.map((x) => <SelectItem key={x} value={x}>{x}</SelectItem>)}</SelectContent>
                                    </Select>
                                    <Button variant="ghost" size="sm" className="h-6" onClick={() => preset && onApplyPreset(preset)}>
                                        Apply
                                    </Button>
                                </div>
                            </div>
                            <Accordion type="single" collapsible className="w-full" value={selectedLightId !== null ? String(selectedLightId) : ""}>
                                {lights.map((light, i) => (
                                    <AccordionItem key={light.id} value={String(light.id)} className="border-b-white/10">
                                        <AccordionTrigger className="flex-1 px-3 py-2 text-xs hover:bg-white/5 rounded-t-md" onClick={() => onSelectLight(light.id === selectedLightId ? null : light.id)}>
                                            <div className="flex items-center justify-between w-full">
                                                <span>Light {i + 1}</span>
                                                <div className="flex items-center gap-1 pr-3" onClick={(e) => e.stopPropagation()}>
                                                    <Button variant="ghost" size="icon" className="h-6 w-6" onClick={() => toggleLightVisibility(light.id)}>
                                                        {light.visible ? <Eye className="h-4 w-4" /> : <EyeOff className="h-4 w-4" />}
                                                    </Button>
                                                    <Button variant="ghost" size="icon" className="h-6 w-6" onClick={() => cloneLight(light.id)}>
                                                        <Clone className="h-3 w-3" />
                                                    </Button>
                                                    <Button variant="ghost" size="icon" className="h-6 w-6" onClick={() => removeLight(light.id)}>
                                                        <Trash2 className="h-3 w-3" />
                                                    </Button>
                                                </div>
                                            </div>
                                        </AccordionTrigger>
                                        <AccordionContent>
                                            <LightSettings light={light} onLightChange={onLightChange} onFocus={onFocusLight} />
                                        </AccordionContent>
                                    </AccordionItem>
                                ))}
                            </Accordion>
                            <div className="flex justify-end pt-2">
                                <Button size="icon" className="h-6 w-6" variant="ghost" onClick={addLight} disabled={lights.length >= 5}>
                                    <Plus className="w-3 h-3" />
                                </Button>
                            </div>
                        </>
                    )}
                </div>

                <Separator className="bg-white/20" />

                <div className="space-y-2">
                    <div className="flex items-center justify-between">
                        <h3 className="text-sm font-semibold">Environment</h3>
                        <Switch checked={environmentEnabled} onCheckedChange={onEnvironmentEnabledChange} />
                    </div>
                    {environmentEnabled && (
                        <div className="space-y-2">
                            <div className="flex items-center justify-between text-xs">
                                <label>Bloom</label>
                                <Switch checked={bloomEnabled} onCheckedChange={onBloomEnabledChange} />
                            </div>
                            <div className="flex items-center justify-between text-xs">
                                <label>Background</label>
                                <Select value={bgType} onValueChange={onBgTypeChange as any}>
                                    <SelectTrigger className="w-1/2 h-6 text-xs bg-white/10 border-white/30">
                                        <SelectValue />
                                    </SelectTrigger>
                                    <SelectContent>
                                        <SelectItem value="color">Color</SelectItem>
                                        <SelectItem value="gradient">Gradient</SelectItem>
                                        <SelectItem value="image">Image</SelectItem>
                                    </SelectContent>
                                </Select>
                            </div>
                            {bgType === "color" && (
                                <div className="flex items-center justify-between text-xs">
                                    <label>Color</label>
                                    <input type="color" value={bgColor1} onChange={(e) => onBgColor1Change(e.target.value)} className="w-6 h-6 p-0 bg-transparent border-none" />
                                </div>
                            )}
                            {bgType === "gradient" && (
                                <>
                                    <div className="flex items-center justify-between text-xs">
                                        <label>Top Color</label>
                                        <input type="color" value={bgColor1} onChange={(e) => onBgColor1Change(e.target.value)} className="w-6 h-6 p-0 bg-transparent border-none" />
                                    </div>
                                    <div className="flex items-center justify-between text-xs">
                                        <label>Bottom Color</label>
                                        <input type="color" value={bgColor2} onChange={(e) => onBgColor2Change(e.target.value)} className="w-6 h-6 p-0 bg-transparent border-none" />
                                    </div>
                                </>
                            )}
                            {bgType === "image" && (
                                <div className="flex items-center justify-between text-xs">
                                    <label>Image</label>
                                    <Button size="icon" className="h-6 w-6" variant="ghost" onClick={() => bgImageInputRef.current?.click()}>
                                        <Upload className="h-3 w-3" />
                                    </Button>
                                    <input type="file" ref={bgImageInputRef} className="hidden" accept="image/*" onChange={handleBgImageUpload} />
                                </div>
                            )}
                        </div>
                    )}
                </div>

                <div className="flex items-center justify-end gap-2">
                    <Button variant="ghost" size="icon" className="h-6 w-6" disabled={!model.view_settings} onClick={onDeleteView}>
                        <Trash2 className="h-3 w-3" />
                    </Button>
                    <Button variant="ghost" size="icon" className="h-6 w-6" onClick={onResetView}>
                        <RotateCcw className="h-4 w-4" />
                    </Button>
                    <Button variant="ghost" size="icon" className="h-6 w-6" onClick={onSaveView}>
                        <Save className="h-3 w-3" />
                    </Button>
                </div>
            </div>
        </div>
    )
}


=== /workspaces/space.iverfinne.no/components/gallery/ui-components.tsx ===

"use client"

import { Button } from "@/components/ui/button"
import { ContextMenu, ContextMenuContent, ContextMenuItem, ContextMenuTrigger } from "@/components/ui/context-menu"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import {
    DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuPortal, DropdownMenuSub, DropdownMenuSubContent,
    DropdownMenuSubTrigger, DropdownMenuTrigger
} from "@/components/ui/dropdown-menu"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import type { Folder, GalleryItem } from "@/types"
import { FolderIcon, FolderSymlink, Globe, Lock, MoreVertical, Pencil, Trash2 } from "lucide-react"
import React, { useState } from "react"
import { toast } from "sonner"

// ---- shared menu ----
interface MenuItemsProps {
    onRename: () => void
    onDelete: () => void
    onMove: (targetFolderId: string | null) => void
    onSetPublic: (isPublic: boolean) => void
    allFolders?: Folder[]
    currentItem: GalleryItem
}

const MoveToList = ({ onMove, allFolders, currentItem, Item }: Omit<MenuItemsProps, "onRename" | "onDelete" | "onSetPublic"> & { Item: any }) => (
    <>
        {currentItem.folder_id !== null && (
            <Item onSelect={() => onMove(null)}>
                <FolderIcon className="mr-2 h-4 w-4" />
                <span>Assets (Root)</span>
            </Item>
        )}
        {allFolders?.filter((f) => f.id !== currentItem.id && f.id !== currentItem.folder_id).map((folder) => (
            <Item key={folder.id} onSelect={() => onMove(folder.id)}>
                <FolderIcon className="mr-2 h-4 w-4" />
                <span>{folder.name}</span>
            </Item>
        ))}
    </>
)

const FullMenu = ({ onRename, onDelete, onMove, onSetPublic, allFolders, currentItem, Item }: MenuItemsProps & { Item: any }) => (
    <>
        <Item onSelect={onRename}><Pencil className="mr-2 h-4 w-4" /><span>Rename</span></Item>
        <DropdownMenuSub>
            <DropdownMenuSubTrigger><FolderSymlink className="mr-2 h-4 w-4" /><span>Move to...</span></DropdownMenuSubTrigger>
            <DropdownMenuPortal>
                <DropdownMenuSubContent><MoveToList onMove={onMove} allFolders={allFolders} currentItem={currentItem} Item={DropdownMenuItem} /></DropdownMenuSubContent>
            </DropdownMenuPortal>
        </DropdownMenuSub>
        <Item onSelect={() => onSetPublic(!currentItem.is_public)}>
            {currentItem.is_public ? <Lock className="mr-2 h-4 w-4" /> : <Globe className="mr-2 h-4 w-4" />}
            <span>Make {currentItem.is_public ? "Private" : "Public"}</span>
        </Item>
        <Item onSelect={onDelete} className="text-destructive focus:text-destructive"><Trash2 className="mr-2 h-4 w-4" /><span>Delete</span></Item>
    </>
)

export function ItemContextMenu({ children, item, onRename, onDelete, onMove, onSetPublic, allFolders }: { children: React.ReactNode } & MenuItemsProps) {
    return (
        <ContextMenu>
            <ContextMenuTrigger className="w-full h-full" onContextMenu={(e) => e.stopPropagation()}>
                <div className="relative group w-full h-full">
                    {children}
                    <div className="absolute top-2 right-2">
                        <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                                <Button variant="ghost" size="icon"
                                    className="h-7 w-7 opacity-0 group-hover:opacity-100 focus-visible:opacity-100 bg-black/30 hover:bg-black/50 text-white hover:text-white"
                                    onClick={(e) => e.stopPropagation()} onContextMenu={(e) => e.stopPropagation()}>
                                    <MoreVertical className="h-4 w-4" />
                                </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent onClick={(e) => e.stopPropagation()}>
                                <FullMenu {...{ onRename, onDelete, onMove, onSetPublic, allFolders, currentItem: item }} Item={DropdownMenuItem} />
                            </DropdownMenuContent>
                        </DropdownMenu>
                    </div>
                </div>
            </ContextMenuTrigger>
            <ContextMenuContent onClick={(e) => e.stopPropagation()}>
                <MoveToList onMove={onMove} allFolders={allFolders} currentItem={item} Item={ContextMenuItem} />
            </ContextMenuContent>
        </ContextMenu>
    )
}

// ---- dialogs ----
export function NewFolderDialog({ open, onOpenChange, onCreate }: { open: boolean; onOpenChange: (o: boolean) => void; onCreate: (name: string) => void }) {
    const [name, setName] = useState("")
    return (
        <Dialog open={open} onOpenChange={onOpenChange}>
            <DialogContent className="bg-black/50 backdrop-blur-sm border-white/20 text-white">
                <DialogHeader><DialogTitle>New Folder</DialogTitle></DialogHeader>
                <Input value={name} onChange={(e) => setName(e.target.value)} placeholder="Enter folder name"
                    onKeyDown={(e) => e.key === "Enter" && name && onCreate(name)} className="bg-white/10 border-white/20" />
                <DialogFooter><Button onClick={() => name && onCreate(name)} disabled={!name}>Create</Button></DialogFooter>
            </DialogContent>
        </Dialog>
    )
}

export function RenameDialog({ item, onOpenChange, onRename }: { item: GalleryItem; onOpenChange: (o: boolean) => void; onRename: (name: string) => void }) {
    const [name, setName] = useState(item.name)
    return (
        <Dialog open={true} onOpenChange={onOpenChange}>
            <DialogContent className="bg-black/50 backdrop-blur-sm border-white/20 text-white">
                <DialogHeader><DialogTitle>Rename {item.type}</DialogTitle></DialogHeader>
                <Input value={name} onChange={(e) => setName(e.target.value)} onKeyDown={(e) => e.key === "Enter" && name && onRename(name)} className="bg-white/10 border-white/20" />
                <DialogFooter><Button onClick={() => name && onRename(name)} disabled={!name}>Save</Button></DialogFooter>
            </DialogContent>
        </Dialog>
    )
}

export function FolderDescriptionDialog({ folder, open, onOpenChange, onSave }: {
    folder: Folder; open: boolean; onOpenChange: (o: boolean) => void; onSave: (description: string) => void
}) {
    const [description, setDescription] = useState(folder.description || "")
    const words = description.trim() ? description.trim().split(/\s+/).length : 0
    const handleSave = () => { if (words > 150) toast.error("Description cannot exceed 150 words."); else onSave(description) }
    return (
        <Dialog open={open} onOpenChange={onOpenChange}>
            <DialogContent className="bg-black/50 backdrop-blur-sm border-white/20 text-white">
                <DialogHeader>
                    <DialogTitle>Edit Description for "{folder.name}"</DialogTitle>
                    <DialogDescription className="text-gray-400">Add a description or comma-separated tags. Used for searching models in this folder.</DialogDescription>
                </DialogHeader>
                <Textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="e.g. sci-fi, characters, hard-surface"
                    className="bg-white/10 border-white/20 min-h-[120px]" rows={5} />
                <div className={`text-right text-sm ${words > 150 ? "text-destructive" : "text-muted-foreground"}`}>{words} / 150 words</div>
                <DialogFooter><Button variant="secondary" onClick={() => onOpenChange(false)}>Cancel</Button><Button onClick={handleSave} disabled={words > 150}>Save</Button></DialogFooter>
            </DialogContent>
        </Dialog>
    )
}


=== /workspaces/space.iverfinne.no/components/gallery/viewer-components.tsx ===

﻿"use client"
import { kelvinToRgb } from "@/lib/utils"
import type { Light } from "@/types"
import { SpotLight, useGLTF } from "@react-three/drei"
import { useThree } from "@react-three/fiber"
import { forwardRef, useEffect, useImperativeHandle, useMemo, useRef } from "react"
import * as THREE from "three"

export function Loader() {
    return null
}

const mkWhite = (m: THREE.Material) =>
    m instanceof THREE.MeshStandardMaterial ? Object.assign(m.clone(), { color: new THREE.Color("white"), map: null }) : new THREE.MeshStandardMaterial({ color: "white" })

const mkNormal = (_: THREE.Material) => new THREE.MeshNormalMaterial()

const mkOverride = (o: {
    color: string
    metalness: number
    roughness: number
    clearcoat: number
    clearcoatRoughness: number
    ior: number
    transmission: number
    map?: THREE.Texture | null
}) => {
    const mat = new THREE.MeshPhysicalMaterial({
        color: o.map ? 0xffffff : new THREE.Color(o.color),
        map: o.map || null,
        metalness: o.metalness,
        roughness: o.roughness,
        clearcoat: o.clearcoat,
        clearcoatRoughness: o.clearcoatRoughness,
        ior: o.ior,
        transmission: o.transmission,
    })
    mat.toneMapped = true
    mat.envMapIntensity = 1
    mat.needsUpdate = true
    return mat
}

export const ModelViewer = forwardRef<
    THREE.Group,
    {
        modelUrl: string
        materialMode: "pbr" | "normal" | "white"
        materialOverride: {
            enabled: boolean
            color: string
            metalness: number
            roughness: number
            clearcoat: number
            clearcoatRoughness: number
            ior: number
            transmission: number
        }
    }
>(({ modelUrl, materialMode, materialOverride }, ref) => {
    const gltf = useGLTF(modelUrl)
    const scene = useMemo(() => gltf.scene.clone(true), [gltf.scene])
    const originals = useRef(new Map<string, THREE.Material | THREE.Material[]>()),
        whites = useRef(new Map<string, THREE.Material | THREE.Material[]>()),
        normals = useRef(new Map<string, THREE.Material | THREE.Material[]>()),
        overrides = useRef(new Map<string, THREE.Material | THREE.Material[]>())

    useEffect(() => {
        const box = new THREE.Box3().setFromObject(scene)
        const center = new THREE.Vector3()
        box.getCenter(center)
        const min = box.min.clone()
        scene.position.x -= center.x
        scene.position.z -= center.z
        scene.position.y -= min.y
        scene.traverse((ch: any) => {
            if (!ch?.isMesh) return
            const mesh = ch as THREE.Mesh
            mesh.castShadow = mesh.receiveShadow = true
            const base = mesh.material
            originals.current.set(mesh.uuid, base)
            const w = Array.isArray(base) ? base.map(mkWhite) : mkWhite(base)
            const n = Array.isArray(base) ? base.map(mkNormal) : mkNormal(base)
            whites.current.set(mesh.uuid, w)
            normals.current.set(mesh.uuid, n)
        })
        return () => {
            ;[whites, normals, overrides].forEach((mapRef) => {
                mapRef.current.forEach((mat) => {
                    if (Array.isArray(mat)) mat.forEach((m) => m.dispose())
                    else mat.dispose()
                })
                mapRef.current.clear()
            })
        }
    }, [scene])

    useEffect(() => {
        if (materialOverride.enabled) return
        scene.traverse((ch: any) => {
            if (!ch?.isMesh) return
            const mesh = ch as THREE.Mesh
            mesh.material =
                materialMode === "white" ? whites.current.get(mesh.uuid)!
                    : materialMode === "normal" ? normals.current.get(mesh.uuid)!
                        : originals.current.get(mesh.uuid)!
        })
    }, [scene, materialMode, materialOverride.enabled])

    useEffect(() => {
        if (!materialOverride.enabled) return
        overrides.current.forEach((mat) => {
            if (Array.isArray(mat)) mat.forEach((m) => m.dispose())
            else mat.dispose()
        })
        overrides.current.clear()
        scene.traverse((ch: any) => {
            if (!ch?.isMesh) return
            const mesh = ch as THREE.Mesh
            const g = mesh.geometry as THREE.BufferGeometry
            if (!g.attributes.normal) {
                g.computeVertexNormals()
                g.normalizeNormals()
            }
            const base = originals.current.get(mesh.uuid)
            if (Array.isArray(base)) {
                const ov = base.map((m: any) =>
                    mkOverride({ ...materialOverride, map: m.map || null })
                )
                overrides.current.set(mesh.uuid, ov)
                mesh.material = ov
            } else {
                const ov = mkOverride({
                    ...materialOverride,
                    map: (base as any)?.map || null,
                })
                overrides.current.set(mesh.uuid, ov)
                mesh.material = ov
            }
        })
    }, [scene, materialOverride])

    return <primitive ref={ref} object={scene} />
})
ModelViewer.displayName = "ModelViewer"

export function SpotLightInScene({ light }: { light: Light }) {
    const target = useRef(new THREE.Object3D())
    const { r, g, b } = kelvinToRgb(light.kelvin)
    const color = useMemo(() => new THREE.Color(r, g, b), [r, g, b])
    useEffect(() => {
        target.current.position.set(...light.targetPosition)
    }, [light.targetPosition])
    if (!light.visible) return null
    return (
        <>
            <SpotLight
                position={light.position}
                target={target.current}
                color={color}
                intensity={light.intensity}
                angle={THREE.MathUtils.degToRad(light.angle)}
                penumbra={light.penumbra}
                decay={light.decay}
                castShadow
                shadow-mapSize={[2048, 2048]}
                shadow-bias={-0.0001}
                shadow-normalBias={0.02}
                distance={light.distance ?? 0}
            />
            <primitive object={target.current} />
        </>
    )
}

export const CaptureController = forwardRef<{ capture: () => Promise<File | null> }, { modelRef: React.RefObject<THREE.Group> }>(
    ({ modelRef }, ref) => {
        const { gl, scene, camera } = useThree()
        useImperativeHandle(ref, () => ({
            async capture() {
                if (!modelRef.current) return null
                const bg = scene.background
                const shadowPlane = scene.children.find((child) => child instanceof THREE.Mesh && child.material instanceof THREE.ShadowMaterial)

                try {
                    if (shadowPlane) shadowPlane.visible = false
                    scene.background = null
                    gl.render(scene, camera)

                    const box = new THREE.Box3().setFromObject(modelRef.current)
                    const v = new THREE.Vector3()
                    const pts = [
                        v.set(box.min.x, box.min.y, box.min.z).clone(),
                        v.set(box.min.x, box.min.y, box.max.z).clone(),
                        v.set(box.min.x, box.max.y, box.min.z).clone(),
                        v.set(box.min.x, box.max.y, box.max.z).clone(),
                        v.set(box.max.x, box.min.y, box.min.z).clone(),
                        v.set(box.max.x, box.min.y, box.max.z).clone(),
                        v.set(box.max.x, box.max.y, box.min.z).clone(),
                        v.set(box.max.x, box.max.y, box.max.z).clone()
                    ]
                    let minX = Infinity,
                        minY = Infinity,
                        maxX = -Infinity,
                        maxY = -Infinity
                    for (const p of pts) {
                        const s = p.clone().project(camera)
                        const x = ((s.x + 1) / 2) * gl.domElement.width,
                            y = (-(s.y - 1) / 2) * gl.domElement.height
                        minX = Math.min(minX, x)
                        maxX = Math.max(maxX, x)
                        minY = Math.min(minY, y)
                        maxY = Math.max(maxY, y)
                    }
                    const bw = maxX - minX,
                        bh = maxY - minY
                    if (bw <= 0 || bh <= 0) {
                        return null
                    }
                    const size = Math.max(bw, bh) * 1.2,
                        cx = minX + bw / 2,
                        cy = minY + bh / 2
                    const sx = cx - size / 2,
                        sy = cy - size / 2
                    const tmp = document.createElement("canvas")
                    tmp.width = 512
                    tmp.height = 512
                    const ctx = tmp.getContext("2d")
                    if (!ctx) {
                        return null
                    }
                    ctx.drawImage(gl.domElement, sx, sy, size, size, 0, 0, 512, 512)
                    const b64 = tmp.toDataURL("image/png")
                    const [meta, data] = b64.split(",")
                    const mime = meta.match(/:(.*?);/)?.[1] ?? "image/png"
                    const bin = atob(data),
                        buf = new Uint8Array(bin.length)
                    for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i)
                    return new File([buf], `thumbnail-${Date.now()}.png`, { type: mime })
                } finally {
                    if (shadowPlane) shadowPlane.visible = true
                    scene.background = bg
                }
            }
        }))
        return null
    }
)
CaptureController.displayName = "CaptureController"


=== /workspaces/space.iverfinne.no/hooks/use-gallery-data.ts ===

"use client"

import type { Folder, GalleryContents } from "@/types"
import { useEffect, useState } from "react"
import { toast } from "sonner"
import useSWR from "swr"

const fetcher = (url: string) => fetch(url).then((res) => res.json())

export function useGalleryData(folderId: string | null, sortBy: string, sortOrder: string) {
    const galleryUrl = `/api/gallery?folderId=${folderId || ""}&sortBy=${sortBy}&sortOrder=${sortOrder}`
    const { data: gallery, error, isLoading, mutate } = useSWR<GalleryContents>(galleryUrl, fetcher)
    const { data: allFolders } = useSWR<Folder[]>("/api/folders/all", fetcher)
    const { data: breadcrumbData, error: breadcrumbError } = useSWR<{ id: string; name: string }[]>(
        folderId ? `/api/folders/${folderId}/breadcrumbs` : null,
        fetcher,
    )

    const [breadcrumbs, setBreadcrumbs] = useState<{ id: string | null; name: string }[]>([{ id: null, name: "Assets" }])

    useEffect(() => {
        if (breadcrumbError) {
            toast.error("Could not load folder path. Please ensure your database schema is up to date.")
        }
        if (folderId === null) {
            setBreadcrumbs([{ id: null, name: "Assets" }])
        } else if (breadcrumbData) {
            setBreadcrumbs([{ id: null, name: "Assets" }, ...breadcrumbData])
        }
    }, [folderId, breadcrumbData, breadcrumbError])

    return { gallery, allFolders, breadcrumbs, error, isLoading, mutateGallery: mutate }
}


=== /workspaces/space.iverfinne.no/hooks/use-item-selection.ts ===

"use client"

import type { GalleryItem } from "@/types"
import { useRef, useState } from "react"

export function useItemSelection(filteredItems: GalleryItem[]) {
    const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set())
    const lastSelectedItem = useRef<string | null>(null)

    const handleItemClick = (e: React.MouseEvent, item: GalleryItem) => {
        e.stopPropagation()
        const newSelectedItems = new Set(selectedItems)

        if (e.shiftKey && lastSelectedItem.current) {
            const lastIndex = filteredItems.findIndex((i) => i.id === lastSelectedItem.current)
            const currentIndex = filteredItems.findIndex((i) => i.id === item.id)
            const [start, end] = [lastIndex, currentIndex].sort((a, b) => a - b)
            for (let i = start; i <= end; i++) {
                newSelectedItems.add(filteredItems[i].id)
            }
        } else if (e.metaKey || e.ctrlKey) {
            newSelectedItems.has(item.id) ? newSelectedItems.delete(item.id) : newSelectedItems.add(item.id)
        } else {
            if (newSelectedItems.size === 1 && newSelectedItems.has(item.id)) {
                newSelectedItems.clear()
            } else {
                newSelectedItems.clear()
                newSelectedItems.add(item.id)
            }
        }

        setSelectedItems(newSelectedItems)
        lastSelectedItem.current = item.id
    }

    return { selectedItems, setSelectedItems, handleItemClick }
}


=== /workspaces/space.iverfinne.no/hooks/use-mobile.tsx ===

"use client"

import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}


=== /workspaces/space.iverfinne.no/hooks/use-viewer-state.ts ===

﻿"use client"

import { lightingPresets } from "@/lib/lighting-presets"
import type { Light, Model, ViewSettings } from "@/types"
import { useCallback, useMemo, useState } from "react"

export function useViewerState(_selectedModel: Model | undefined) {
    const defaultLights: Light[] = useMemo(() => {
        const preset = lightingPresets.find((p) => p.name === "3-Point")?.lights ?? []
        return preset.map((l, i) => ({ ...l, id: Date.now() + i, visible: true }))
    }, [])

    const [materialMode, setMaterialMode] = useState<"pbr" | "normal" | "white">("white")
    const [lightsEnabled, onLightsEnabledChange] = useState(true)
    const [environmentEnabled, onEnvironmentEnabledChange] = useState(false)
    const [bloomEnabled, onBloomEnabledChange] = useState(false)
    const [bgType, onBgTypeChange] = useState<"color" | "gradient" | "image">("color")
    const [bgColor1, onBgColor1Change] = useState("#000000")
    const [bgColor2, onBgColor2Change] = useState("#1a1a1a")
    const [bgImage, onBgImageChange] = useState<string | null>(null)
    const [lights, setLights] = useState<Light[]>(defaultLights)
    const [selectedLightId, setSelectedLightId] = useState<number | null>(null)

    const resetViewSettings = useCallback(
        (s: ViewSettings | null | undefined) => {
            setLights(s?.lights?.map((l, i) => ({ ...l, id: Date.now() + i, visible: true })) ?? defaultLights)
            onLightsEnabledChange(s?.lightsEnabled ?? true)
            onEnvironmentEnabledChange(s?.environmentEnabled ?? false)
            onBloomEnabledChange(s?.bloomEnabled ?? false)
            onBgTypeChange(s?.bgType ?? "color")
            onBgColor1Change(s?.bgColor1 ?? "#000000")
            onBgColor2Change(s?.bgColor2 ?? "#1a1a1a")
            onBgImageChange(s?.bgImage ?? null)
            setMaterialMode(s?.materialMode ?? "white")
            setSelectedLightId(null)
        },
        [defaultLights],
    )

    return {
        materialMode,
        setMaterialMode,
        lightsEnabled,
        onLightsEnabledChange,
        environmentEnabled,
        onEnvironmentEnabledChange,
        bloomEnabled,
        onBloomEnabledChange,
        bgType,
        onBgTypeChange,
        bgColor1,
        onBgColor1Change,
        bgColor2,
        onBgColor2Change,
        bgImage,
        onBgImageChange,
        lights,
        setLights,
        selectedLightId,
        setSelectedLightId,
        resetViewSettings,
    }
}


=== /workspaces/space.iverfinne.no/lib/gallery-actions.ts ===

import type { GalleryItem, Model, ViewSettings } from "@/types"
import { upload } from "@vercel/blob/client"
import { toast } from "sonner"
import type { KeyedMutator } from "swr"

type MutateGallery = KeyedMutator<any>

export async function handleUpload(
    files: FileList | null,
    currentFolderId: string | null,
    mutateGallery: MutateGallery,
    updateQuery: (params: Record<string, string | null>) => void,
) {
    if (!files || files.length === 0) return
    const fileArray = Array.from(files)
    const uploadedModels: Model[] = []

    const uploadToast = toast.loading(`Uploading ${fileArray.length} file(s)...`)

    await Promise.all(
        fileArray.map(async (file) => {
            if (!file.name.endsWith(".glb")) {
                toast.error(`Skipping non-GLB file: ${file.name}`)
                return
            }
            try {
                const newBlob = await upload(file.name.replace(/\s+/g, "_"), file, {
                    access: "public",
                    handleUploadUrl: "/api/upload",
                })

                const res = await fetch("/api/models", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        name: file.name.replace(/\.glb$/, ""),
                        model_url: newBlob.url,
                        thumbnail_url: `/placeholder.svg?width=400&height=400&query=${encodeURIComponent(
                            file.name.replace(/\.glb$/, ""),
                        )}`,
                        folder_id: currentFolderId,
                    }),
                })

                if (!res.ok) throw new Error(`Failed to create database record for ${file.name}`)
                const newModel = await res.json()
                uploadedModels.push(newModel)

                toast.success(`Uploaded ${file.name}`, { id: uploadToast, duration: 2000 })
            } catch (error) {
                toast.error(`Failed to upload ${file.name}`, { id: uploadToast })
            }
        }),
    )

    mutateGallery()
    if (uploadedModels.length === 1) {
        updateQuery({ modelId: uploadedModels[0].id })
    }
}

export async function handleThumbnailUpload(
    file: File,
    modelId: string,
    mutateGallery: MutateGallery,
    mutateSelectedModel: KeyedMutator<Model>,
) {
    try {
        toast.info(`Uploading thumbnail...`)
        const pathname = `thumbnails/${modelId}.${file.name.split(".").pop()}`
        const newBlob = await upload(pathname, file, {
            access: "public",
            handleUploadUrl: "/api/upload",
            clientPayload: JSON.stringify({ isThumbnail: true }),
        })

        await fetch(`/api/models/${modelId}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ thumbnail_url: newBlob.url }),
        })

        await mutateGallery()
        await mutateSelectedModel()
        toast.success("Thumbnail updated successfully!")
    } catch (error) {
        console.error("Thumbnail upload failed:", error)
        toast.error(error instanceof Error ? error.message : "Failed to upload thumbnail.")
    }
}

export async function createFolder(name: string, parent_id: string | null, mutateGallery: MutateGallery) {
    await fetch("/api/folders", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, parent_id }),
    })
    toast.success(`Folder "${name}" created`)
    mutateGallery()
}

export async function renameItem(
    item: GalleryItem,
    newName: string,
    mutateGallery: MutateGallery,
    mutateSelectedModel?: KeyedMutator<Model>,
) {
    const url = item.type === "folder" ? `/api/folders/${item.id}` : `/api/models/${item.id}`
    await fetch(url, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: newName }),
    })
    toast.success("Renamed successfully")
    mutateGallery()
    if (item.type === "model" && mutateSelectedModel) mutateSelectedModel()
}

async function performBulkAction(
    items: GalleryItem[],
    action: (item: GalleryItem) => Promise<Response>,
    successMessage: string,
    mutators: { closeViewer: () => void; mutateGallery: MutateGallery },
) {
    if (items.length === 0) return;
    const toastId = toast.loading(`Processing ${items.length} item(s)...`);

    const results = await Promise.allSettled(items.map(action));

    let successCount = 0;
    let failureCount = 0;
    results.forEach(result => {
        if (result.status === 'fulfilled' && result.value.ok) {
            successCount++;
        } else {
            failureCount++;
        }
    });

    if (failureCount > 0) {
        toast.error(`${successCount} ${successMessage}, ${failureCount} failed.`, { id: toastId });
    } else {
        toast.success(`${successCount} ${successMessage}.`, { id: toastId });
    }

    if (items.some(item => item.type === 'model')) {
        mutators.closeViewer();
    }
    mutators.mutateGallery();
}


export async function deleteItems(items: GalleryItem[], closeViewer: () => void, mutateGallery: MutateGallery) {
    const deleteAction = (item: GalleryItem) => {
        const url = item.type === "folder" ? `/api/folders/${item.id}` : `/api/models/${item.id}`;
        return fetch(url, { method: "DELETE" });
    };
    await performBulkAction(items, deleteAction, "item(s) deleted", { closeViewer, mutateGallery });
}

export async function moveItems(
    items: GalleryItem[],
    targetFolderId: string | null,
    currentFolderId: string | null,
    closeViewer: () => void,
    mutateGallery: MutateGallery,
) {
    const moveAction = (item: GalleryItem) => {
        const url = item.type === "folder" ? `/api/folders/${item.id}` : `/api/models/${item.id}`;
        const body = item.type === "folder" ? { parent_id: targetFolderId } : { folder_id: targetFolderId };
        return fetch(url, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
        });
    };

    const shouldCloseViewer = items.some(item => item.type === 'model') && targetFolderId !== currentFolderId;
    await performBulkAction(items, moveAction, "item(s) moved", { closeViewer: shouldCloseViewer ? closeViewer : () => { }, mutateGallery });
}


export async function setItemPublic(
    items: GalleryItem[],
    isPublic: boolean,
    mutateGallery: MutateGallery,
    mutateSelectedModel?: KeyedMutator<Model>,
) {
    const setPublicAction = (item: GalleryItem) => {
        const url = item.type === "folder" ? `/api/folders/${item.id}` : `/api/models/${item.id}`;
        return fetch(url, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ is_public: isPublic }),
        });
    };
    await performBulkAction(items, setPublicAction, `item(s) set to ${isPublic ? "public" : "private"}`, { closeViewer: () => { }, mutateGallery });
    if (items.some(item => item.type === 'model') && mutateSelectedModel) {
        mutateSelectedModel();
    }
}


export async function saveViewSettings(modelId: string, settings: ViewSettings) {
    await fetch(`/api/models/${modelId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ view_settings: settings }),
    })
    toast.success("Default view saved!")
}

export async function deleteViewSettings(modelId: string) {
    await fetch(`/api/models/${modelId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ view_settings: null }),
    })
    toast.success("Saved view has been deleted.")
}


=== /workspaces/space.iverfinne.no/lib/lighting-presets.ts ===

// === /workspaces/space.iverfinne.no/lib/lighting-presets.ts ===
import type { Light } from "@/types";

type LightPreset = Omit<Light, "id" | "visible">

export const lightingPresets: { name: string; lights: LightPreset[] }[] = [
  {
    name: "3-Point",
    lights: [
      // Increased key light intensity for stronger default
      { position: [-2.5, 2.2, 3.2], targetPosition: [0, 0.6, 0], intensity: 28, kelvin: 5600, decay: 1.6, angle: 38, penumbra: 0.4 },
      { position: [2.8, 1.2, 2.2], targetPosition: [0, 0.6, 0], intensity: 8, kelvin: 4200, decay: 2.0, angle: 55, penumbra: 0.7 },
      { position: [0.0, 2.0, -2.4], targetPosition: [0, 0.4, 0], intensity: 18, kelvin: 7000, decay: 1.8, angle: 50, penumbra: 0.5 },
    ],
  },
  {
    name: "Studio Soft",
    lights: [
      { position: [0, 3.5, 2.2], targetPosition: [0, 0.5, 0], intensity: 16, kelvin: 6500, decay: 1.2, angle: 85, penumbra: 1.0 },
      { position: [-3, 2, 3], targetPosition: [0, 0.5, 0], intensity: 6, kelvin: 6000, decay: 1.8, angle: 65, penumbra: 0.8 },
    ],
  },
  {
    name: "Hard Rim",
    lights: [
      { position: [3.5, 1.5, -2.5], targetPosition: [0, 0.7, 0], intensity: 28, kelvin: 7500, decay: 1.6, angle: 30, penumbra: 0.3 },
      { position: [-3.0, 1.0, 2.5], targetPosition: [0, 0.6, 0], intensity: 10, kelvin: 4000, decay: 2.0, angle: 45, penumbra: 0.5 },
    ],
  },
  {
    name: "Moody",
    lights: [
      { position: [-1.5, 1.2, 1.8], targetPosition: [0, 0.4, 0], intensity: 10, kelvin: 3200, decay: 1.4, angle: 25, penumbra: 0.6 },
      { position: [1.4, 0.8, -2.0], targetPosition: [0, 0.3, 0], intensity: 14, kelvin: 9000, decay: 1.8, angle: 35, penumbra: 0.4 },
    ],
  },
]


=== /workspaces/space.iverfinne.no/lib/supabase-server.ts ===

import { createClient } from "@supabase/supabase-js"

// These variables are available in the Vercel environment
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY

if (!supabaseUrl || !supabaseServiceKey) {
  // This check is important for local development and debugging.
  // In production on Vercel, these variables should be set.
  console.warn(
    "Supabase URL or Service Role Key is not defined in environment variables. Database operations will likely fail.",
  )
}

// Note: this client is for server-side use only, as it uses the service_role key.
// It bypasses Row Level Security (RLS).
export const supabaseServer = createClient(supabaseUrl!, supabaseServiceKey!)


=== /workspaces/space.iverfinne.no/lib/utils.ts ===

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function kelvinToRgb(kelvin: number): { r: number; g: number; b: number } {
  const temp = kelvin / 100
  let r: number, g: number, b: number

  // Calculate Red
  if (temp <= 66) {
    r = 255
  } else {
    r = temp - 60
    r = 329.698727446 * Math.pow(r, -0.1332047592)
  }

  // Calculate Green
  if (temp <= 66) {
    g = temp
    g = 99.4708025861 * Math.log(g) - 161.1195681661
  } else {
    g = temp - 60
    g = 288.1221695283 * Math.pow(g, -0.0755148492)
  }

  // Calculate Blue
  if (temp >= 66) {
    b = 255
  } else {
    if (temp <= 19) {
      b = 0
    } else {
      b = temp - 10
      b = 138.5177312231 * Math.log(b) - 305.0447927307
    }
  }

  const clamp = (val: number) => Math.max(0, Math.min(255, val))

  return { r: clamp(r) / 255, g: clamp(g) / 255, b: clamp(b) / 255 }
}


=== /workspaces/space.iverfinne.no/types/index.ts ===

export interface Light {
  id: number
  visible: boolean
  position: [number, number, number]
  targetPosition: [number, number, number]
  intensity: number
  kelvin: number
  decay: number
  angle: number
  penumbra: number
  volumeOpacity?: number
  distance?: number
}

export interface ViewSettings {
  lights: Omit<Light, "id" | "visible">[]
  lightsEnabled: boolean
  environmentEnabled: boolean
  bloomEnabled: boolean
  ssaoEnabled: boolean
  bgType: "color" | "gradient" | "image"
  bgColor1: string
  bgColor2: string
  bgImage: string | null
  fov: number
  orthographic: boolean
  cameraPosition: [number, number, number] | null
  cameraTarget: [number, number, number] | null
  materialMode: "pbr" | "normal" | "white"
  materialOverride?: {
    enabled: boolean
    color: string
    metalness: number
    roughness: number
    clearcoat: number
    clearcoatRoughness: number
    ior: number
    transmission: number
  }
}

export interface Model {
  id: string
  name: string
  model_url: string
  thumbnail_url: string
  created_at: string
  folder_id: string | null
  is_public: boolean
  view_settings: ViewSettings | null
}

export interface Folder {
  id: string
  name: string
  parent_id: string | null
  created_at: string
  description?: string
  is_public: boolean
}

export interface GalleryContents {
  folders: Folder[]
  models: Model[]
  currentFolder: Folder | null
}

export type GalleryItem = ({ type: "folder" } & Folder) | ({ type: "model" } & Model)


